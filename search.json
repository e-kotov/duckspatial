[{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://cidree.github.io/duckspatial/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://cidree.github.io/duckspatial/articles/aw_interpolation.html","id":"setup-data","dir":"Articles","previous_headings":"","what":"Setup Data","title":"Areal Interpolation","text":"use North Carolina dataset sf package source, create generic grid target. Note: project data Albers Equal Area (EPSG:5070) accurate interpolation requires equal-area projection.","code":"library(duckspatial) library(sf)  # 1. Load Source Data (NC Counties) nc <- st_read(system.file(\"shape/nc.shp\", package = \"sf\"), quiet = TRUE)  # 2. Transform to projected CRS (Albers) for accurate area calculations nc <- st_transform(nc, 5070)  # 3. Create a Target Grid grid <- st_make_grid(nc, n = c(10, 5)) |> st_as_sf()  # 4. Create Unique IDs (Required for interpolation) nc$source_id <- 1:nrow(nc) grid$target_id <- 1:nrow(grid)"},{"path":"https://cidree.github.io/duckspatial/articles/aw_interpolation.html","id":"extensive-vs--intensive-interpolation","dir":"Articles","previous_headings":"","what":"1) Extensive vs. Intensive Interpolation","title":"Areal Interpolation","text":"Areal interpolation works differently depending nature data.","code":""},{"path":"https://cidree.github.io/duckspatial/articles/aw_interpolation.html","id":"case-a-extensive-variables-counts","dir":"Articles","previous_headings":"1) Extensive vs. Intensive Interpolation","what":"Case A: Extensive Variables (Counts)","title":"Areal Interpolation","text":"Variables like population counts total births (BIR74) spatially extensive. source polygon split half, count also split half. use weight = \"total\" ensure strict mass preservation relative source. Verification: total sum births result match original data (mass preservation).","code":"# Interpolate Total Births (Extensive) res_extensive <- ddbs_interpolate_aw(   target = grid,   source = nc,   tid = \"target_id\",   sid = \"source_id\",   extensive = \"BIR74\",   weight = \"total\",   output = \"sf\" ) #> ✔ Query successful orig_sum <- sum(nc$BIR74) new_sum  <- sum(res_extensive$BIR74, na.rm = TRUE)  sprintf(\"Original: %s | Interpolated: %s\", orig_sum, round(new_sum, 1)) #> [1] \"Original: 329962 | Interpolated: 329962\""},{"path":"https://cidree.github.io/duckspatial/articles/aw_interpolation.html","id":"case-b-intensive-variables-densitiesratios","dir":"Articles","previous_headings":"1) Extensive vs. Intensive Interpolation","what":"Case B: Intensive Variables (Densities/Ratios)","title":"Areal Interpolation","text":"Variables like population density infection rates spatially intensive. source polygon split, density remains pieces. duckspatial handles calculating area-weighted average.","code":"# Interpolate 'BIR74' treating it as an intensive variable (e.g. density assumption) res_intensive <- ddbs_interpolate_aw(   target = grid,   source = nc,   tid = \"target_id\",   sid = \"source_id\",   intensive = \"BIR74\", # Treated as density here   weight = \"sum\",      # Standard behavior for intensive vars   output = \"sf\" ) #> ✔ Query successful"},{"path":"https://cidree.github.io/duckspatial/articles/aw_interpolation.html","id":"visual-comparison","dir":"Articles","previous_headings":"1) Extensive vs. Intensive Interpolation","what":"Visual Comparison","title":"Areal Interpolation","text":"Notice difference patterns. Extensive interpolation accumulates values based much “stuff” falls grid cell, intensive interpolation smoothes values based overlap.","code":"# Combine for plotting plot_data <- res_extensive[, \"BIR74\"] names(plot_data)[1] <- \"Extensive_Count\" plot_data$Intensive_Value <- res_intensive$BIR74  plot(plot_data[c(\"Extensive_Count\", \"Intensive_Value\")],       main = \"Interpolation Methods Comparison\",      border = \"grey90\",      key.pos = 4)"},{"path":"https://cidree.github.io/duckspatial/articles/aw_interpolation.html","id":"high-performance-output-as-tibble","dir":"Articles","previous_headings":"","what":"2) High Performance: Output as Tibble","title":"Areal Interpolation","text":"working massive datasets, constructing geometry result sf object can slow. need interpolated numbers, set output = \"tibble\". skips geometry construction step significantly faster.","code":"# Return a standard data.frame/tibble without geometry res_tbl <- ddbs_interpolate_aw(   target = grid,   source = nc,   tid = \"target_id\",   sid = \"source_id\",   extensive = \"BIR74\",   output = \"tibble\" ) #> ✔ Query successful  head(res_tbl) #> # A tibble: 6 × 3 #>   target_id crs_duckspatial BIR74 #>       <int> <chr>           <dbl> #> 1         1 EPSG:5070       1168. #> 2         2 EPSG:5070        379. #> 3         6 EPSG:5070        753. #> 4         7 EPSG:5070       5731. #> 5         8 EPSG:5070       8000. #> 6        11 EPSG:5070       1417."},{"path":"https://cidree.github.io/duckspatial/articles/aw_interpolation.html","id":"database-mode-large-data-workflows","dir":"Articles","previous_headings":"","what":"3) Database Mode: Large Data Workflows","title":"Areal Interpolation","text":"datasets larger memory, persistent pipelines, can perform interpolation directly inside DuckDB database without pulling data R end. First, let’s establish connection load spatial layers tables. Now run interpolation referencing table names. can also use name argument save result directly new table instead returning R. can now query table read back later. wanted database table, without geometry, : preview table directly database:","code":"# Create connection conn <- ddbs_create_conn()  # Write layers to DuckDB ddbs_write_vector(conn, nc, \"nc_table\", overwrite = TRUE) #> ℹ Table <nc_table> dropped #> ✔ Table nc_table successfully imported ddbs_write_vector(conn, grid, \"grid_table\", overwrite = TRUE) #> ℹ Table <grid_table> dropped #> ✔ Table grid_table successfully imported # Run interpolation and save to new table 'nc_grid_births' ddbs_interpolate_aw(   conn = conn,   target = \"grid_table\",   source = \"nc_table\",   tid = \"target_id\",   sid = \"source_id\",   extensive = \"BIR74\",   weight = \"total\",   name = \"nc_grid_births\", # <--- Writes to DB   overwrite = TRUE ) #> ℹ Table <nc_grid_births> dropped #> ✔ Query successful  # Verify the table was created DBI::dbListTables(conn) #> [1] \"grid_table\"     \"nc_grid_births\" \"nc_table\" # Read the result back from the database final_sf <- ddbs_read_vector(conn, \"nc_grid_births\") #> ✔ table nc_grid_births successfully imported.  head(final_sf) #> Simple feature collection with 6 features and 2 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1054293 ymin: 1348021 xmax: 1677656 ymax: 1484503 #> Projected CRS: NAD83 / Conus Albers #>   target_id     BIR74                              x #> 1         1 1168.3093 POLYGON ((1054293 1348021, ... #> 2         2  378.5281 POLYGON ((1132214 1348021, ... #> 3         6  752.9156 POLYGON ((1443895 1348021, ... #> 4         7 5731.0103 POLYGON ((1521815 1348021, ... #> 5         8 7999.6957 POLYGON ((1599735 1348021, ... #> 6        11 1416.5579 POLYGON ((1054293 1416262, ... ddbs_interpolate_aw(   conn = conn,   target = \"grid_table\",   source = \"nc_table\",   tid = \"target_id\",   sid = \"source_id\",   extensive = \"BIR74\",   weight = \"total\",   name = \"nc_grid_births\", # <--- Writes to DB   overwrite = TRUE,   output = \"tibble\" ) #> ℹ Table <nc_grid_births> dropped #> ✔ Query successful DBI::dbGetQuery(conn, \"SELECT * FROM nc_grid_births LIMIT 5\") #>   target_id crs_duckspatial     BIR74 #> 1         1       EPSG:5070 1168.3093 #> 2         2       EPSG:5070  378.5281 #> 3         6       EPSG:5070  752.9156 #> 4         7       EPSG:5070 5731.0103 #> 5         8       EPSG:5070 7999.6957"},{"path":"https://cidree.github.io/duckspatial/articles/aw_interpolation.html","id":"cleanup","dir":"Articles","previous_headings":"3) Database Mode: Large Data Workflows","what":"Cleanup","title":"Areal Interpolation","text":"Always close connection finished.","code":"duckdb::dbDisconnect(conn)"},{"path":"https://cidree.github.io/duckspatial/articles/benchmark.html","id":"spatial-join","dir":"Articles","previous_headings":"","what":"Spatial Join","title":"Benchmark","text":"analyze {duckspatial} {sf} compare performing spatial join points polygons increasingly large numbers points.","code":""},{"path":"https://cidree.github.io/duckspatial/articles/benchmark.html","id":"tldr","dir":"Articles","previous_headings":"Spatial Join","what":"TL;DR","title":"Benchmark","text":"{sf} faster small data sets, time memory differences really don’t matter much. However, large data sets (e.g. 100K points), {duckspatial} much faster uses way less memory. Now let’s look results. one expect, {sf} faster small data sets, time difference less couple seconds. larger data sets, though, {duckspatial} gets much efficient. example working 10 million points, {duckspatial} 50% faster used 4.1 times less memory {sf}. bad.","code":"library(duckspatial) library(bench) library(dplyr) library(ggplot2)  # read polygons data countries_sf <- sf::st_read(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) #> Reading layer `countries' from data source  #>   `/home/runner/work/_temp/Library/duckspatial/spatial/countries.geojson'  #>   using driver `GeoJSON' #> Simple feature collection with 257 features and 6 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: -178.9125 ymin: -89.9 xmax: 180 ymax: 83.65187 #> Geodetic CRS:  WGS 84  run_benchmark <- function(n){          set.seed(42)      ## create points data     points_sf <- data.frame(         id = 1:n,         x = runif(n, min = -180, max = 180),           y = runif(n, min = -90, max = 90)         ) |>          sf::st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)          temp_bench <- bench::mark(         iterations = 1,          check = FALSE,          duckspatial = duckspatial::ddbs_join(             x = points_sf,              y = countries_sf,              join = \"within\"),                  sf = sf::st_join(             x = points_sf,              y = countries_sf,              join = sf::st_within)         )          temp_bench$n <- n     temp_bench$pkg <- c(\"duckspatial\", \"sf\")          return(temp_bench) }   # From 10K points to 10 million points df_bench <- lapply(     X = c(10e3, 10e4, 10e5),     FUN = run_benchmark     ) |>      dplyr::bind_rows() #> Warning: Some expressions had a GC in every iteration; so filtering is #> disabled. #> Warning: Some expressions had a GC in every iteration; so filtering is #> disabled. ggplot(data = df_bench) +     geom_point(size =3, aes(x= mem_alloc, y = median, color = pkg,                      shape = format(n, big.mark = \".\")                     )) +     labs(color= \"Package\", shape = \"Data size\",          y = \"Computation time (seconds)\",          x = \"Memory allocated\") +     theme_minimal()"},{"path":"https://cidree.github.io/duckspatial/articles/spatial_joins.html","id":"in-memory-pass-sf-return-sf","dir":"Articles","previous_headings":"","what":"1) In-memory: pass sf, return sf","title":"Spatial joins","text":"simplest way perform fast spatial join. simply pass two sf objects, ddbs_join() spins temporary DuckDB, runs join, returns sf. use: quick analysis, prototyping, don’t need persist intermediate tables.","code":"out_sf1 <- ddbs_join(   x    = points_sf,   y    = countries_sf,   join = \"within\" )  # quick peek # mapview(out_sf1, zcol=\"NAME_ENGL\")"},{"path":"https://cidree.github.io/duckspatial/articles/spatial_joins.html","id":"connected-pass-table-names-in-duckdb-return-sf","dir":"Articles","previous_headings":"","what":"2) Connected: pass table names in DuckDB, return sf","title":"Spatial joins","text":"second third approaches, make use connection existing DuckDB database. let’s create fresh DuckDB connection using ddbs_create_conn() function, automatically install load DuckDB spatial extension connection. Now, second approach need first write layers DuckDB, perform spatial join referencing table names. Like : use: iterative workflows, larger--memory data, ’ll run multiple queries tables.","code":"# create a fresh DuckDB connection conn <- duckspatial::ddbs_create_conn() # write data to DuckDB ddbs_write_vector(conn, points_sf,   \"points\",    overwrite = TRUE) ddbs_write_vector(conn, countries_sf, \"countries\", overwrite = TRUE)  # spatial join inside DuckDB; result returned as sf out_sf2 <- ddbs_join(   conn,   x    = \"points\",   y    = \"countries\",   join = \"within\" )"},{"path":"https://cidree.github.io/duckspatial/articles/spatial_joins.html","id":"write-to-db-create-a-new-table-with-the-join-result","dir":"Articles","previous_headings":"","what":"3) Write-to-DB: create a new table with the join result","title":"Spatial joins","text":"output approaches 1 2 sf object loaded memory. third approach, ddbs_join() writes new table DuckDB database. simply need name new table. use: iterative workflows, larger--memory data, ’ll run multiple queries tables.","code":"ddbs_join(     conn = conn,     x = \"points\",     y = \"countries\",     join = \"within\",     name = \"points_in_countries\",     overwrite = TRUE )  # use the result in SQL (or read back as sf later) # DBI::dbReadTable(conn, \"points_in_countries\") |> #     sf::st_as_sf(wkt = 'geometry') |>  #     head()"},{"path":"https://cidree.github.io/duckspatial/articles/spatial_joins.html","id":"spatial-join-predicates","dir":"Articles","previous_headings":"","what":"Spatial Join Predicates:","title":"Spatial joins","text":"spatial predicate really just function evaluates spatial relation two geometries returns true false, e.g., “contain b” “within distance x b”. join argument accepts spatial predicates: \"ST_Intersects\": Whether intersects b \"ST_Contains\": Whether contains b \"ST_ContainsProperly\": Whether contains b without b touching ’s boundary \"ST_Within\": Whether within b \"ST_Overlaps\": Whether overlaps b \"ST_Touches\": Whether touches b \"ST_Equals\": Whether equal b \"ST_Crosses\": Whether crosses b \"ST_Covers\": Whether covers b \"ST_CoveredBy\": Whether covered b \"ST_DWithin\": x) Whether within distance x b","code":""},{"path":"https://cidree.github.io/duckspatial/articles/spatial_joins.html","id":"clean-up","dir":"Articles","previous_headings":"","what":"Clean up","title":"Spatial joins","text":"Don’t forget disconnect database.","code":"duckdb::dbDisconnect(conn)"},{"path":"https://cidree.github.io/duckspatial/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Adrián Cidre González. Author, maintainer. Rafael H. M. Pereira. Author. Egor Kotov. Author.","code":""},{"path":"https://cidree.github.io/duckspatial/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Cidre González , Pereira R, Kotov E (2025). duckspatial: R Interface 'DuckDB' Database Spatial Extension. R package version 0.2.0999, https://cidree.github.io/duckspatial/.","code":"@Manual{,   title = {duckspatial: R Interface to 'DuckDB' Database with Spatial Extension},   author = {Adrián {Cidre González} and Rafael H. M. Pereira and Egor Kotov},   year = {2025},   note = {R package version 0.2.0999},   url = {https://cidree.github.io/duckspatial/}, }"},{"path":"https://cidree.github.io/duckspatial/index.html","id":"duckspatial-","dir":"","previous_headings":"","what":"R Interface to DuckDB Database with Spatial Extension","title":"R Interface to DuckDB Database with Spatial Extension","text":"duckspatial R package simplifies process reading writing vector spatial data (e.g., sf objects) DuckDB database. package designed users working geospatial data want leverage DuckDB’s fast analytical capabilities maintaining compatibility R’s spatial data ecosystem.","code":""},{"path":"https://cidree.github.io/duckspatial/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"R Interface to DuckDB Database with Spatial Extension","text":"can install duckspatial directly CRAN : can install development version GitHub :","code":"install.packages(\"duckspatial\") # install.packages(\"pak\") pak::pak(\"Cidree/duckspatial\")"},{"path":"https://cidree.github.io/duckspatial/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"R Interface to DuckDB Database with Spatial Extension","text":"basic example shows set DuckDB spatial data manipulation, write/read vector data. First, create connection DuckDB database (case memory database), make sure spatial extension installed, load : Now can get data insert database. creating 10,000,000 random points. Now can insert data database using ddbs_write_vector() function. use proc.time() function calculate long take, can compare writing shapefile write_sf() function: case, can see DuckDB 12.8 times faster. can also take advantage Arrow-backend database view using argument temp_view = TRUE: 25.4 times faster sf, 2 times faster create table DuckDB. Now exercise reading data back R: reading, got similar results. Finally, don’t forget disconnect database:","code":"library(duckdb) #> Loading required package: DBI library(duckspatial) library(sf) #> Linking to GEOS 3.13.1, GDAL 3.11.0, PROJ 9.6.0; sf_use_s2() is TRUE ## create connection conn <- dbConnect(duckdb())  ## install and load spatial extension ddbs_install(conn) #> ℹ spatial extension version <d83faf8> is already installed in this database ddbs_load(conn) #> ✔ Spatial extension loaded ## random word generator random_word <- function(length = 5) {     paste0(sample(letters, length, replace = TRUE), collapse = \"\") }  ## create n points n <- 10000000 random_points <- data.frame(   id = 1:n,   x = runif(n, min = -180, max = 180),     y = runif(n, min = -90, max = 90),   a = sample(1:1000000, size = n, replace = TRUE),   b = sample(replicate(10, random_word(7)), size = n, replace = TRUE),   c = sample(replicate(10, random_word(9)), size = n, replace = TRUE) )  ## convert to sf sf_points <- st_as_sf(random_points, coords = c(\"x\", \"y\"), crs = 4326)  ## view first rows head(sf_points) #> Simple feature collection with 6 features and 4 fields #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: -124.2864 ymin: -72.15126 xmax: 163.8672 ymax: 75.7669 #> Geodetic CRS:  WGS 84 #>   id      a       b         c                    geometry #> 1  1 859568 coymaff jetjsaflm POINT (-124.2864 -37.90519) #> 2  2 598415 ppqzgog ilctisjkg   POINT (163.8672 53.59711) #> 3  3  50455 rzsltum kkcannydo POINT (-59.45239 -64.17698) #> 4  4 901453 nwmhqfb yhpawnmnl  POINT (57.81578 -72.15126) #> 5  5 424225 tspgmop yhpawnmnl   POINT (86.6534 -38.47388) #> 6  6 954935 coymaff yhpawnmnl   POINT (-116.6155 75.7669) ## write data monitoring processing time start_time <- proc.time() ddbs_write_vector(conn, sf_points, \"test_points\") #> ✔ Table test_points successfully imported end_time <- proc.time()  ## print elapsed time elapsed_duckdb <- end_time[\"elapsed\"] - start_time[\"elapsed\"] print(elapsed_duckdb) #> elapsed  #>    7.73 ## write data monitoring processing time start_time <- proc.time() gpkg_file <- tempfile(fileext = \".gpkg\") write_sf(sf_points, gpkg_file) end_time <- proc.time()  ## print elapsed time elapsed_gpkg <- end_time[\"elapsed\"] - start_time[\"elapsed\"] print(elapsed_gpkg) #> elapsed  #>   98.67 ## write data monitoring processing time start_time <- proc.time() ddbs_write_vector(conn, sf_points, \"test_points_view\", temp_view = TRUE) #> ✔ Temporary view test_points_view registered end_time <- proc.time()  ## print elapsed time elapsed_duckdb_view <- end_time[\"elapsed\"] - start_time[\"elapsed\"] print(elapsed_duckdb_view) #> elapsed  #>    3.89 ## write data monitoring processing time start_time <- proc.time() sf_points_ddbs <- ddbs_read_vector(conn, \"test_points\") #> ✔ table test_points successfully imported. end_time <- proc.time()  ## print elapsed time elapsed_duckdb <- end_time[\"elapsed\"] - start_time[\"elapsed\"] print(elapsed_duckdb) #> elapsed  #>   37.67 ## write data monitoring processing time start_time     <- proc.time() sf_points_ddbs <- read_sf(gpkg_file) end_time       <- proc.time()  ## print elapsed time elapsed_gpkg <- end_time[\"elapsed\"] - start_time[\"elapsed\"] print(elapsed_gpkg) #> elapsed  #>   31.26 dbDisconnect(conn)"},{"path":"https://cidree.github.io/duckspatial/reference/convert_to_sf.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts from data frame to sf — convert_to_sf","title":"Converts from data frame to sf — convert_to_sf","text":"Converts table read DuckDB sf object","code":""},{"path":"https://cidree.github.io/duckspatial/reference/convert_to_sf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts from data frame to sf — convert_to_sf","text":"","code":"convert_to_sf(data, crs, crs_column, x_geom)"},{"path":"https://cidree.github.io/duckspatial/reference/convert_to_sf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts from data frame to sf — convert_to_sf","text":"data tibble data frame crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. x_geom name geometry","code":""},{"path":"https://cidree.github.io/duckspatial/reference/convert_to_sf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts from data frame to sf — convert_to_sf","text":"sf","code":""},{"path":"https://cidree.github.io/duckspatial/reference/convert_to_sf_native_geoarrow.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts from data frame to sf using native geoarrow — convert_to_sf_native_geoarrow","title":"Converts from data frame to sf using native geoarrow — convert_to_sf_native_geoarrow","text":"Converts table read DuckDB sf object. Optimized handle Arrow-native binary streams using wk geoarrow.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/convert_to_sf_native_geoarrow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts from data frame to sf using native geoarrow — convert_to_sf_native_geoarrow","text":"","code":"convert_to_sf_native_geoarrow(data, crs, crs_column, x_geom)"},{"path":"https://cidree.github.io/duckspatial/reference/convert_to_sf_native_geoarrow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts from data frame to sf using native geoarrow — convert_to_sf_native_geoarrow","text":"data tibble data frame crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. x_geom name geometry column","code":""},{"path":"https://cidree.github.io/duckspatial/reference/convert_to_sf_native_geoarrow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts from data frame to sf using native geoarrow — convert_to_sf_native_geoarrow","text":"sf","code":""},{"path":"https://cidree.github.io/duckspatial/reference/dbConnCheck.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if a supported DuckDB connection — dbConnCheck","title":"Check if a supported DuckDB connection — dbConnCheck","text":"Check supported DuckDB connection","code":""},{"path":"https://cidree.github.io/duckspatial/reference/dbConnCheck.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if a supported DuckDB connection — dbConnCheck","text":"","code":"dbConnCheck(conn)"},{"path":"https://cidree.github.io/duckspatial/reference/dbConnCheck.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if a supported DuckDB connection — dbConnCheck","text":"conn connection object DuckDB database","code":""},{"path":"https://cidree.github.io/duckspatial/reference/dbConnCheck.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if a supported DuckDB connection — dbConnCheck","text":"TRUE (invisibly) successful import","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_area.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates the area of geometries — ddbs_area","title":"Calculates the area of geometries — ddbs_area","text":"Calculates area geometries DuckDB table sf object Returns result sf object area column creates new table database. Note: Area units depend CRS input geometries (e.g., square meters projected CRS, degrees geographic CRS).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_area.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates the area of geometries — ddbs_area","text":"","code":"ddbs_area(   x,   conn = NULL,   name = NULL,   new_column = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_area.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates the area of geometries — ddbs_area","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object new_column Name new column create input data. NULL, function return vector result crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_area.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates the area of geometries — ddbs_area","text":"vector, sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_area.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates the area of geometries — ddbs_area","text":"","code":"## load packages library(duckspatial) library(sf) #> Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_sf <- st_read(system.file(\"spatial/argentina.geojson\", package = \"duckspatial\")) |>     st_transform(\"EPSG:3857\") #> Reading layer `argentina' from data source  #>   `/home/runner/work/_temp/Library/duckspatial/spatial/argentina.geojson'  #>   using driver `GeoJSON' #> Simple feature collection with 1 feature and 6 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: -73.52455 ymin: -52.39755 xmax: -53.62409 ymax: -21.81793 #> Geodetic CRS:  WGS 84  ## store in duckdb ddbs_write_vector(conn, argentina_sf, \"argentina\") #> ✔ Table argentina successfully imported  ## calculate area (returns sf object with area column) ddbs_area(\"argentina\", conn) #> [1] 4.253708e+12  ## calculate area with custom column name ddbs_area(\"argentina\", conn, new_column = \"area_sqm\") #> ✔ Query successful #> Simple feature collection with 1 feature and 7 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: -8184715 ymin: -6872329 xmax: -5969406 ymax: -2489680 #> Projected CRS: WGS 84 / Pseudo-Mercator #>   CNTR_ID NAME_ENGL ISO3_CODE CNTR_NAME FID       date     area_sqm #> 1      AR Argentina       ARG Argentina  AR 2021-01-01 4.253708e+12 #>                         geometry #> 1 POLYGON ((-6973632 -2541624...  ## create a new table with area calculations ddbs_area(\"argentina\", conn, name = \"argentina_with_area\") #> [1] 4.253708e+12  ## calculate area in a sf object ddbs_area(argentina_sf) #> [1] 4.253708e+12"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_bbox.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns the minimal bounding box enclosing the input geometry — ddbs_bbox","title":"Returns the minimal bounding box enclosing the input geometry — ddbs_bbox","text":"Returns minimal bounding box enclosing input geometry sf object DuckDB table. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_bbox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns the minimal bounding box enclosing the input geometry — ddbs_bbox","text":"","code":"ddbs_bbox(   x,   by_feature = FALSE,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_bbox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns the minimal bounding box enclosing the input geometry — ddbs_bbox","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. by_feature Boolean. function defaults FALSE, returns single bounding box x. TRUE, return one bounding box feature. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_bbox.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns the minimal bounding box enclosing the input geometry — ddbs_bbox","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_bbox.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns the minimal bounding box enclosing the input geometry — ddbs_bbox","text":"","code":"## load packages library(duckspatial) library(sf)  ## read data argentina_sf <- st_read(system.file(\"spatial/argentina.geojson\", package = \"duckspatial\")) #> Reading layer `argentina' from data source  #>   `/home/runner/work/_temp/Library/duckspatial/spatial/argentina.geojson'  #>   using driver `GeoJSON' #> Simple feature collection with 1 feature and 6 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: -73.52455 ymin: -52.39755 xmax: -53.62409 ymax: -21.81793 #> Geodetic CRS:  WGS 84  # option 1: passing sf objects ddbs_bbox(argentina_sf) #> ✔ Query successful #>       min_x     min_y     max_x     max_y #> 1 -73.52455 -52.39755 -53.62409 -21.81793   ## option 2: passing the names of tables in a duckdb db  # creates a duckdb write sf to it conn <- duckspatial::ddbs_create_conn() ddbs_write_vector(conn, argentina_sf, \"argentina_tbl\", overwrite = TRUE) #> ℹ Table <argentina_tbl> dropped #> ✔ Table argentina_tbl successfully imported  output2 <- ddbs_bbox(     conn = conn,     x = \"argentina_tbl\",     name = \"argentina_bbox\" ) #> ✔ Query successful  DBI::dbReadTable(conn, \"argentina_bbox\") #>       min_x     min_y     max_x     max_y #> 1 -73.52455 -52.39755 -53.62409 -21.81793"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_boundary.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns the boundary of geometries — ddbs_boundary","title":"Returns the boundary of geometries — ddbs_boundary","text":"Returns boundary geometries sf object DuckDB table. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_boundary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns the boundary of geometries — ddbs_boundary","text":"","code":"ddbs_boundary(   x,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_boundary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns the boundary of geometries — ddbs_boundary","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_boundary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns the boundary of geometries — ddbs_boundary","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_boundary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns the boundary of geometries — ddbs_boundary","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  # read data argentina_sf <- st_read(system.file(\"spatial/argentina.geojson\", package = \"duckspatial\"))  # store in duckdb ddbs_write_vector(conn, argentina_sf, \"argentina\")  # boundary b <- ddbs_boundary(x = \"argentina\", conn) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_buffer.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a buffer around geometries — ddbs_buffer","title":"Creates a buffer around geometries — ddbs_buffer","text":"Calculates buffer geometries DuckDB table using spatial extension. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_buffer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a buffer around geometries — ddbs_buffer","text":"","code":"ddbs_buffer(   x,   distance,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_buffer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a buffer around geometries — ddbs_buffer","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. distance numeric value specifying buffer distance. Units correspond coordinate system geometry (e.g. degrees meters) conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_buffer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a buffer around geometries — ddbs_buffer","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_buffer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates a buffer around geometries — ddbs_buffer","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_sf <- st_read(system.file(\"spatial/argentina.geojson\", package = \"duckspatial\"))  ## store in duckdb ddbs_write_vector(conn, argentina_sf, \"argentina\")  ## buffer ddbs_buffer(conn = conn, \"argentina\", distance = 1)  ## buffer without using a connection ddbs_buffer(argentina_sf, distance = 1) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_centroid.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates the centroid of geometries — ddbs_centroid","title":"Calculates the centroid of geometries — ddbs_centroid","text":"Calculates centroids geometries DuckDB table using spatial extension. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_centroid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates the centroid of geometries — ddbs_centroid","text":"","code":"ddbs_centroid(   x,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_centroid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates the centroid of geometries — ddbs_centroid","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_centroid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates the centroid of geometries — ddbs_centroid","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_centroid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates the centroid of geometries — ddbs_centroid","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_sf <- st_read(system.file(\"spatial/argentina.geojson\", package = \"duckspatial\"))  ## store in duckdb ddbs_write_vector(conn, argentina_sf, \"argentina\")  ## centroid ddbs_centroid(\"argentina\", conn)  ## centroid without using a connection ddbs_centroid(argentina_sf) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_combine.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine geometries into a single MULTI-geometry — ddbs_combine","title":"Combine geometries into a single MULTI-geometry — ddbs_combine","text":"Combines geometries sf object DuckDB table single MULTI-geometry using spatial extension. equivalent sf::st_combine(). Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_combine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine geometries into a single MULTI-geometry — ddbs_combine","text":"","code":"ddbs_combine(   x,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_combine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine geometries into a single MULTI-geometry — ddbs_combine","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string specifying name CRS column. Default \"crs_duckspatial\" overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_combine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine geometries into a single MULTI-geometry — ddbs_combine","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_combine.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine geometries into a single MULTI-geometry — ddbs_combine","text":"","code":"if (FALSE) { # \\dontrun{ # load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  # read data countries_sf <- st_read(system.file(\"spatial/countries.geojson\", package = \"duckspatial\"))  # store in duckdb ddbs_write_vector(conn, countries_sf, \"countries\")  # combine all geometries into one ddbs_combine(conn = conn, \"countries\")  # combine without using a connection ddbs_combine(countries_sf)  # store result in a new table ddbs_combine(conn = conn, \"countries\", name = \"countries_combined\") } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_concave_hull.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns the concave hull enclosing the geometry — ddbs_concave_hull","title":"Returns the concave hull enclosing the geometry — ddbs_concave_hull","text":"Returns concave hull enclosing geometry sf object DuckDB table using spatial extension. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_concave_hull.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns the concave hull enclosing the geometry — ddbs_concave_hull","text":"","code":"ddbs_concave_hull(   x,   ratio = 0.5,   allow_holes = TRUE,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_concave_hull.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns the concave hull enclosing the geometry — ddbs_concave_hull","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. ratio Numeric. ratio parameter dictates level concavity; 1 returns convex hull, 0 indicates return concave hull possible. Defaults 0.5. allow_holes Boolean. TRUE (default), allows output contain holes. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_concave_hull.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns the concave hull enclosing the geometry — ddbs_concave_hull","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_concave_hull.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns the concave hull enclosing the geometry — ddbs_concave_hull","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create points data n <- 5 points_sf <- data.frame(     id = 1,     x = runif(n, min = -180, max = 180),     y = runif(n, min = -90, max = 90)     ) |>     sf::st_as_sf(coords = c(\"x\", \"y\"), crs = 4326) |>     st_geometry() |>     st_combine() |>     st_cast(\"MULTIPOINT\") |>     st_as_sf()  # option 1: passing sf objects output1 <- duckspatial::ddbs_concave_hull(x = points_sf)  plot(output1)   # option 2: passing the name of a table in a duckdb db  # creates a duckdb conn <- duckspatial::ddbs_create_conn()  # write sf to duckdb ddbs_write_vector(conn, points_sf, \"points_tbl\")  # spatial join output2 <- duckspatial::ddbs_concave_hull(     conn = conn,     x = \"points_tbl\"     )  plot(output2)  } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_contains.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial contains predicate — ddbs_contains","title":"Spatial contains predicate — ddbs_contains","text":"Tests geometries x contain geometries y. Returns TRUE geometry x completely contains geometry y.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_contains.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial contains predicate — ddbs_contains","text":"","code":"ddbs_contains(   x,   y,   conn = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_contains.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial contains predicate — ddbs_contains","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. id_x Character; optional name column x whose values used name list elements. NULL, integer row numbers x used. id_y Character; optional name column y whose values replace integer indices returned element list. sparse logical value. TRUE, returns sparse index list. FALSE, returns dense logical matrix. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_contains.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial contains predicate — ddbs_contains","text":"list element contains indices (IDs) geometries y contained corresponding geometry x. See ddbs_predicate() details.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_contains.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial contains predicate — ddbs_contains","text":"convenience wrapper around ddbs_predicate() predicate = \"contains\".","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_contains.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial contains predicate — ddbs_contains","text":"","code":"## load packages library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union library(duckspatial) library(sf)  ## read countries data, and rivers countries_sf <- read_sf(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\")) rivers_sf <- st_read(system.file(\"spatial/rivers.geojson\", package = \"duckspatial\")) |>   st_transform(st_crs(countries_sf)) #> Reading layer `rivers' from data source  #>   `/home/runner/work/_temp/Library/duckspatial/spatial/rivers.geojson'  #>   using driver `GeoJSON' #> Simple feature collection with 100 features and 1 field #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 2766878 ymin: 2222357 xmax: 3578648 ymax: 2459939 #> Projected CRS: ETRS89-extended / LAEA Europe  ddbs_contains(countries_sf, rivers_sf, id_x = \"NAME_ENGL\", id_y = \"RIVER_NAME\") #> ✔ Query successful #> $Spain #>  [1] \"Rio Garona\"         \"Baztan Ibaia\"       \"Oria Ibaia\"         #>  [4] \"Oria Ibaia\"         \"Deba Ibaia\"         \"Rio Nervion\"        #>  [7] \"Ibaizabal Ibaia\"    \"Rio Agüera O Mayor\" \"Rio Ason\"           #> [10] \"Rio Miera\"          \"Rio Pas\"            \"Rio Saja\"           #> [13] \"Rio Besaya\"         \"Rio Nansa\"          \"Rio Cares\"          #> [16] \"Rio Piloña\"         \"Rio Nalon\"          \"Rio Narcea\"         #> [19] \"Rio Pigüeña\"        \"Rio Nora\"           \"Rio Trubia\"         #> [22] \"Rio Esva\"           \"Rio Barcena\"        \"Rio Navia\"          #> [25] \"Rio Navia\"          \"Rio Navia\"          \"Rio Navia\"          #> [28] \"Rio Agueira\"        \"Rio Masma\"          \"Rio Landro\"         #> [31] \"Rio Mera\"           \"Rio Eume\"           \"Rio Eume\"           #> [34] \"Rio Eume\"           \"Rio Mandeo\"         \"Rio Mero\"           #> [37] \"Rio Anllons\"        \"Rio Xallas\"         \"Rio Xallas\"         #> [40] \"Rio Xallas\"         \"Rio Tambre\"         \"Rio Ulla\"           #> [43] \"Rio Ulla\"           \"Rio Ulla\"           \"Rio Arnego\"         #> [46] \"Rio Arnego\"         \"Rio Umia\"           \"Rio Lerez\"          #> [49] \"Rio Verdugo\"        \"Rio Miño\"           \"Rio Miño\"           #> [52] \"Rio Miño\"           \"Rio Miño\"           \"Rio Miño\"           #> [55] \"Rio Miño\"           \"Rio Miño\"           \"Rio Tea\"            #> [58] \"Rio Arnoia\"         \"Rio Avia\"           \"Rio Avia\"           #> [61] \"Rio Avia\"           \"Rio Sil\"            \"Rio Sil\"            #> [64] \"Rio Sil\"            \"Rio Sil\"            \"Rio Sil\"            #> [67] \"Rio Cabe\"           \"Rio Mao\"            \"Rio Bibei\"          #> [70] \"Rio Bibei\"          \"Rio Bibei\"          \"Rio Xares\"          #> [73] \"Rio Xares\"          \"Rio Xares\"          \"Rio Conso\"          #> [76] \"Rio Conso\"          \"Rio Camba\"          \"Rio Camba\"          #> [79] \"Rio Camba\"          \"Rio Camba\"          \"Rio Selmo\"          #> [82] \"Rio Burbia\"         \"Rio Boeza\"          \"Rio Neira\"          #> [85] \"Rio Ladra\"          \"Rio Parga\"          \"Rio Limia\"          #> [88] \"Rio Limia\"          \"Rio Limia\"          \"Rio Salas\"          #>  #> $France #> integer(0) #>  #> $Italy #> integer(0) #>  #> $Portugal #> integer(0) #>"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_contains_properly.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial contains properly predicate — ddbs_contains_properly","title":"Spatial contains properly predicate — ddbs_contains_properly","text":"Tests geometries x properly contain geometries y. Returns TRUE geometry y completely inside geometry x touch boundary.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_contains_properly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial contains properly predicate — ddbs_contains_properly","text":"","code":"ddbs_contains_properly(   x,   y,   conn = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_contains_properly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial contains properly predicate — ddbs_contains_properly","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. id_x Character; optional name column x whose values used name list elements. NULL, integer row numbers x used. id_y Character; optional name column y whose values replace integer indices returned element list. sparse logical value. TRUE, returns sparse index list. FALSE, returns dense logical matrix. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_contains_properly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial contains properly predicate — ddbs_contains_properly","text":"list element contains indices (IDs) geometries y properly contained corresponding geometry x. See ddbs_predicate() details.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_contains_properly.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial contains properly predicate — ddbs_contains_properly","text":"convenience wrapper around ddbs_predicate() predicate = \"contains_properly\".","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_contains_properly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial contains properly predicate — ddbs_contains_properly","text":"","code":"## load packages library(dplyr) library(duckspatial) library(sf)  ## read countries data, and rivers countries_sf <- read_sf(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\")) rivers_sf <- st_read(system.file(\"spatial/rivers.geojson\", package = \"duckspatial\")) |>   st_transform(st_crs(countries_sf)) #> Reading layer `rivers' from data source  #>   `/home/runner/work/_temp/Library/duckspatial/spatial/rivers.geojson'  #>   using driver `GeoJSON' #> Simple feature collection with 100 features and 1 field #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 2766878 ymin: 2222357 xmax: 3578648 ymax: 2459939 #> Projected CRS: ETRS89-extended / LAEA Europe  ddbs_contains_properly(countries_sf, rivers_sf, id_x = \"NAME_ENGL\", id_y = \"RIVER_NAME\") #> ✔ Query successful #> $Spain #>  [1] \"Rio Garona\"         \"Baztan Ibaia\"       \"Oria Ibaia\"         #>  [4] \"Oria Ibaia\"         \"Deba Ibaia\"         \"Rio Nervion\"        #>  [7] \"Ibaizabal Ibaia\"    \"Rio Agüera O Mayor\" \"Rio Ason\"           #> [10] \"Rio Miera\"          \"Rio Pas\"            \"Rio Saja\"           #> [13] \"Rio Besaya\"         \"Rio Nansa\"          \"Rio Cares\"          #> [16] \"Rio Piloña\"         \"Rio Nalon\"          \"Rio Narcea\"         #> [19] \"Rio Pigüeña\"        \"Rio Nora\"           \"Rio Trubia\"         #> [22] \"Rio Esva\"           \"Rio Barcena\"        \"Rio Navia\"          #> [25] \"Rio Navia\"          \"Rio Navia\"          \"Rio Navia\"          #> [28] \"Rio Agueira\"        \"Rio Masma\"          \"Rio Landro\"         #> [31] \"Rio Mera\"           \"Rio Eume\"           \"Rio Eume\"           #> [34] \"Rio Eume\"           \"Rio Mandeo\"         \"Rio Mero\"           #> [37] \"Rio Anllons\"        \"Rio Xallas\"         \"Rio Xallas\"         #> [40] \"Rio Xallas\"         \"Rio Tambre\"         \"Rio Ulla\"           #> [43] \"Rio Ulla\"           \"Rio Ulla\"           \"Rio Arnego\"         #> [46] \"Rio Arnego\"         \"Rio Umia\"           \"Rio Lerez\"          #> [49] \"Rio Verdugo\"        \"Rio Miño\"           \"Rio Miño\"           #> [52] \"Rio Miño\"           \"Rio Miño\"           \"Rio Miño\"           #> [55] \"Rio Miño\"           \"Rio Miño\"           \"Rio Tea\"            #> [58] \"Rio Arnoia\"         \"Rio Avia\"           \"Rio Avia\"           #> [61] \"Rio Avia\"           \"Rio Sil\"            \"Rio Sil\"            #> [64] \"Rio Sil\"            \"Rio Sil\"            \"Rio Sil\"            #> [67] \"Rio Cabe\"           \"Rio Mao\"            \"Rio Bibei\"          #> [70] \"Rio Bibei\"          \"Rio Bibei\"          \"Rio Xares\"          #> [73] \"Rio Xares\"          \"Rio Xares\"          \"Rio Conso\"          #> [76] \"Rio Conso\"          \"Rio Camba\"          \"Rio Camba\"          #> [79] \"Rio Camba\"          \"Rio Camba\"          \"Rio Selmo\"          #> [82] \"Rio Burbia\"         \"Rio Boeza\"          \"Rio Neira\"          #> [85] \"Rio Ladra\"          \"Rio Parga\"          \"Rio Limia\"          #> [88] \"Rio Limia\"          \"Rio Limia\"          \"Rio Salas\"          #>  #> $France #> integer(0) #>  #> $Italy #> integer(0) #>  #> $Portugal #> integer(0) #>"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_convex_hull.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns the convex hull enclosing the geometry — ddbs_convex_hull","title":"Returns the convex hull enclosing the geometry — ddbs_convex_hull","text":"Returns convex hull enclosing geometry sf object DuckDB table using spatial extension. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_convex_hull.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns the convex hull enclosing the geometry — ddbs_convex_hull","text":"","code":"ddbs_convex_hull(   x,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_convex_hull.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns the convex hull enclosing the geometry — ddbs_convex_hull","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_convex_hull.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns the convex hull enclosing the geometry — ddbs_convex_hull","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_convex_hull.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns the convex hull enclosing the geometry — ddbs_convex_hull","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  # read data argentina_sf <- st_read(system.file(\"spatial/argentina.geojson\", package = \"duckspatial\"))  # option 1: passing sf objects output1 <- duckspatial::ddbs_convex_hull(x = argentina_sf)  plot(output1[\"CNTR_NAME\"])#' # store in duckdb  # option 2: passing the name of a table in a duckdb db  # creates a duckdb conn <- duckspatial::ddbs_create_conn()  # write sf to duckdb ddbs_write_vector(conn, argentina_sf, \"argentina_tbl\")  # spatial join output2 <- duckspatial::ddbs_convex_hull(     conn = conn,     x = \"argentina_tbl\"     )  plot(output2[\"CNTR_NAME\"]) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_covered_by.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial covered by predicate — ddbs_covered_by","title":"Spatial covered by predicate — ddbs_covered_by","text":"Tests geometries x covered geometries y. Returns TRUE geometry x completely covered geometry y (point x lies outside y).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_covered_by.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial covered by predicate — ddbs_covered_by","text":"","code":"ddbs_covered_by(   x,   y,   conn = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_covered_by.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial covered by predicate — ddbs_covered_by","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. id_x Character; optional name column x whose values used name list elements. NULL, integer row numbers x used. id_y Character; optional name column y whose values replace integer indices returned element list. sparse logical value. TRUE, returns sparse index list. FALSE, returns dense logical matrix. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_covered_by.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial covered by predicate — ddbs_covered_by","text":"list element contains indices (IDs) geometries y cover corresponding geometry x. See ddbs_predicate() details.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_covered_by.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial covered by predicate — ddbs_covered_by","text":"convenience wrapper around ddbs_predicate() predicate = \"covered_by\".","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_covered_by.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial covered by predicate — ddbs_covered_by","text":"","code":"## load packages library(dplyr) library(duckspatial) library(sf)  ## read countries data, and rivers countries_sf <- read_sf(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\")) rivers_sf <- st_read(system.file(\"spatial/rivers.geojson\", package = \"duckspatial\")) |>   st_transform(st_crs(countries_sf)) #> Reading layer `rivers' from data source  #>   `/home/runner/work/_temp/Library/duckspatial/spatial/rivers.geojson'  #>   using driver `GeoJSON' #> Simple feature collection with 100 features and 1 field #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 2766878 ymin: 2222357 xmax: 3578648 ymax: 2459939 #> Projected CRS: ETRS89-extended / LAEA Europe  ddbs_covered_by(rivers_sf, countries_sf, id_x = \"RIVER_NAME\", id_y = \"NAME_ENGL\") #> ✔ Query successful #> $`Rio Garona` #> [1] \"Spain\" \"Italy\" #>  #> $`Bidasoa Ibaia` #> [1] \"Spain\"    \"France\"   \"Portugal\" #>  #> $`Baztan Ibaia` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Urumea` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Oria Ibaia` #> [1] \"Spain\" \"Italy\" #>  #> $`Oria Ibaia` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Urola Ibaia` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Deba Ibaia` #> [1] \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Nervion` #> [1] \"Spain\"    \"France\"   \"Portugal\" #>  #> $`Ibaizabal Ibaia` #> [1] \"Spain\"    \"Italy\"    \"Portugal\" #>  #> $`Rio Agüera O Mayor` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Ason` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Miera` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Pas` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Saja` #> [1] \"Spain\"    \"France\"   \"Portugal\" #>  #> $`Rio Besaya` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Nansa` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Deva` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Cares` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Sella` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Piloña` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Nalon` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Narcea` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Pigüeña` #> [1] \"Spain\"  \"France\" \"Italy\"  #>  #> $`Rio Nora` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Trubia` #> integer(0) #>  #> $`Rio Esva` #> integer(0) #>  #> $`Rio Barcena` #> integer(0) #>  #> $`Rio Navia` #> integer(0) #>  #> $`Rio Navia` #> integer(0) #>  #> $`Rio Navia` #> integer(0) #>  #> $`Rio Navia` #> integer(0) #>  #> $`Rio Navia` #> integer(0) #>  #> $`Rio Agueira` #> integer(0) #>  #> $`Rio Eo` #> integer(0) #>  #> $`Rio Masma` #> integer(0) #>  #> $`Rio Landro` #> integer(0) #>  #> $`Rio Sor` #> integer(0) #>  #> $`Rio Mera` #> integer(0) #>  #> $`Rio Eume` #> integer(0) #>  #> $`Rio Eume` #> integer(0) #>  #> $`Rio Eume` #> integer(0) #>  #> $`Rio Mandeo` #> integer(0) #>  #> $`Rio Mero` #> integer(0) #>  #> $`Rio Anllons` #> integer(0) #>  #> $`Rio Xallas` #> integer(0) #>  #> $`Rio Xallas` #> integer(0) #>  #> $`Rio Xallas` #> integer(0) #>  #> $`Rio Tambre` #> integer(0) #>  #> $`Rio Ulla` #> integer(0) #>  #> $`Rio Ulla` #> integer(0) #>  #> $`Rio Ulla` #> integer(0) #>  #> $`Rio Arnego` #> integer(0) #>  #> $`Rio Arnego` #> integer(0) #>  #> $`Rio Umia` #> integer(0) #>  #> $`Rio Lerez` #> integer(0) #>  #> $`Rio Verdugo` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Tea` #> integer(0) #>  #> $`Rio Arnoia` #> integer(0) #>  #> $`Rio Avia` #> integer(0) #>  #> $`Rio Avia` #> integer(0) #>  #> $`Rio Avia` #> integer(0) #>  #> $`Rio Sil` #> integer(0) #>  #> $`Rio Sil` #> integer(0) #>  #> $`Rio Sil` #> integer(0) #>  #> $`Rio Sil` #> integer(0) #>  #> $`Rio Sil` #> integer(0) #>  #> $`Rio Cabe` #> integer(0) #>  #> $`Rio Mao` #> integer(0) #>  #> $`Rio Bibei` #> integer(0) #>  #> $`Rio Bibei` #> integer(0) #>  #> $`Rio Bibei` #> integer(0) #>  #> $`Rio Xares` #> integer(0) #>  #> $`Rio Xares` #> integer(0) #>  #> $`Rio Xares` #> integer(0) #>  #> $`Rio Conso` #> integer(0) #>  #> $`Rio Conso` #> integer(0) #>  #> $`Rio Camba` #> integer(0) #>  #> $`Rio Camba` #> integer(0) #>  #> $`Rio Camba` #> integer(0) #>  #> $`Rio Camba` #> integer(0) #>  #> $`Rio Selmo` #> integer(0) #>  #> $`Rio Burbia` #> integer(0) #>  #> $`Rio Boeza` #> integer(0) #>  #> $`Rio Neira` #> integer(0) #>  #> $`Rio Ladra` #> integer(0) #>  #> $`Rio Parga` #> integer(0) #>  #> $`Rio Limia` #> integer(0) #>  #> $`Rio Limia` #> integer(0) #>  #> $`Rio Limia` #> integer(0) #>  #> $`Rio Limia` #> integer(0) #>  #> $`Rio Salas` #> integer(0) #>"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_covers.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial covers predicate — ddbs_covers","title":"Spatial covers predicate — ddbs_covers","text":"Tests geometries x cover geometries y. Returns TRUE geometry x completely covers geometry y (point y lies outside x).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_covers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial covers predicate — ddbs_covers","text":"","code":"ddbs_covers(   x,   y,   conn = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_covers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial covers predicate — ddbs_covers","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. id_x Character; optional name column x whose values used name list elements. NULL, integer row numbers x used. id_y Character; optional name column y whose values replace integer indices returned element list. sparse logical value. TRUE, returns sparse index list. FALSE, returns dense logical matrix. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_covers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial covers predicate — ddbs_covers","text":"list element contains indices (IDs) geometries y covered corresponding geometry x. See ddbs_predicate() details.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_covers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial covers predicate — ddbs_covers","text":"convenience wrapper around ddbs_predicate() predicate = \"covers\".","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_covers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial covers predicate — ddbs_covers","text":"","code":"## load packages library(dplyr) library(duckspatial) library(sf)  ## read countries data, and rivers countries_sf <- read_sf(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\")) rivers_sf <- st_read(system.file(\"spatial/rivers.geojson\", package = \"duckspatial\")) |>   st_transform(st_crs(countries_sf)) #> Reading layer `rivers' from data source  #>   `/home/runner/work/_temp/Library/duckspatial/spatial/rivers.geojson'  #>   using driver `GeoJSON' #> Simple feature collection with 100 features and 1 field #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 2766878 ymin: 2222357 xmax: 3578648 ymax: 2459939 #> Projected CRS: ETRS89-extended / LAEA Europe  ddbs_covers(countries_sf, rivers_sf, id_x = \"NAME_ENGL\") #> ✔ Query successful #> $Spain #>  [1]   1   3   5   6   8   9  10  11  12  13  14  15  16  17  19  21  22  23  24 #> [20]  25  26  27  28  30  31  32  33  34  36  37  39  40  41  42  43  44  45  46 #> [39]  47  48  49  50  51  52  53  54  55  56  57  58  60  61  62  63  64  65  66 #> [58]  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84  85 #> [77]  86  87  88  89  90  91  92  93  94  95  97  98  99 100 #>  #> $France #> integer(0) #>  #> $Italy #> integer(0) #>  #> $Portugal #> integer(0) #>"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_conn.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a DuckDB connection with spatial extension — ddbs_create_conn","title":"Create a DuckDB connection with spatial extension — ddbs_create_conn","text":"creates DuckDB connection, installs loads spatial extension","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_conn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a DuckDB connection with spatial extension — ddbs_create_conn","text":"","code":"ddbs_create_conn(dbdir = \"memory\")"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_conn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a DuckDB connection with spatial extension — ddbs_create_conn","text":"dbdir String. Either \"tempdir\" \"memory\". Defaults \"memory\".","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_conn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a DuckDB connection with spatial extension — ddbs_create_conn","text":"duckdb_connection","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_conn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a DuckDB connection with spatial extension — ddbs_create_conn","text":"","code":"if (FALSE) { # interactive() # load packages library(duckspatial)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  # create a duckdb database in disk  (with spatial extension) conn <- ddbs_create_conn(dbdir = \"tempdir\") }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Check and create schema — ddbs_create_schema","title":"Check and create schema — ddbs_create_schema","text":"Check create schema","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check and create schema — ddbs_create_schema","text":"","code":"ddbs_create_schema(conn, name, quiet = FALSE)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check and create schema — ddbs_create_schema","text":"conn connection object DuckDB database name character string name schema created quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check and create schema — ddbs_create_schema","text":"TRUE (invisibly) successful schema creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_create_schema.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check and create schema — ddbs_create_schema","text":"","code":"## load packages library(duckspatial) library(duckdb) #> Loading required package: DBI  ## connect to in memory database conn <- ddbs_create_conn(dbdir = \"memory\")  ## create a new schema ddbs_create_schema(conn, \"new_schema\") #> ✔ Schema new_schema created  ## check schemas dbGetQuery(conn, \"SELECT * FROM information_schema.schemata;\") #>   catalog_name        schema_name schema_owner default_character_set_catalog #> 1       memory               main       duckdb                          <NA> #> 2       memory         new_schema       duckdb                          <NA> #> 3       system information_schema       duckdb                          <NA> #> 4       system               main       duckdb                          <NA> #> 5       system         pg_catalog       duckdb                          <NA> #> 6         temp               main       duckdb                          <NA> #>   default_character_set_schema default_character_set_name sql_path #> 1                         <NA>                       <NA>     <NA> #> 2                         <NA>                       <NA>     <NA> #> 3                         <NA>                       <NA>     <NA> #> 4                         <NA>                       <NA>     <NA> #> 5                         <NA>                       <NA>     <NA> #> 6                         <NA>                       <NA>     <NA>  ## disconnect from db ddbs_stop_conn(conn)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_crosses.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial crosses predicate — ddbs_crosses","title":"Spatial crosses predicate — ddbs_crosses","text":"Tests geometries x cross geometries y. Returns TRUE geometries interior points common.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_crosses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial crosses predicate — ddbs_crosses","text":"","code":"ddbs_crosses(   x,   y,   conn = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_crosses.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial crosses predicate — ddbs_crosses","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. id_x Character; optional name column x whose values used name list elements. NULL, integer row numbers x used. id_y Character; optional name column y whose values replace integer indices returned element list. sparse logical value. TRUE, returns sparse index list. FALSE, returns dense logical matrix. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_crosses.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial crosses predicate — ddbs_crosses","text":"list element contains indices (IDs) geometries y cross corresponding geometry x. See ddbs_predicate() details.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_crosses.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial crosses predicate — ddbs_crosses","text":"convenience wrapper around ddbs_predicate() predicate = \"crosses\".","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_crosses.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial crosses predicate — ddbs_crosses","text":"","code":"## load packages library(dplyr) library(duckspatial) library(sf)  ## read countries data, and rivers countries_sf <- read_sf(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\")) rivers_sf <- st_read(system.file(\"spatial/rivers.geojson\", package = \"duckspatial\")) |>   st_transform(st_crs(countries_sf)) #> Reading layer `rivers' from data source  #>   `/home/runner/work/_temp/Library/duckspatial/spatial/rivers.geojson'  #>   using driver `GeoJSON' #> Simple feature collection with 100 features and 1 field #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 2766878 ymin: 2222357 xmax: 3578648 ymax: 2459939 #> Projected CRS: ETRS89-extended / LAEA Europe  ddbs_crosses(rivers_sf, countries_sf, id_x = \"RIVER_NAME\", id_y = \"NAME_ENGL\") #> ✔ Query successful #> $`Rio Garona` #> [1] \"France\"   \"Portugal\" #>  #> $`Bidasoa Ibaia` #> [1] \"Italy\" #>  #> $`Baztan Ibaia` #> integer(0) #>  #> $`Rio Urumea` #> integer(0) #>  #> $`Oria Ibaia` #> [1] \"France\"   \"Portugal\" #>  #> $`Oria Ibaia` #> integer(0) #>  #> $`Urola Ibaia` #> integer(0) #>  #> $`Deba Ibaia` #> [1] \"Spain\" #>  #> $`Rio Nervion` #> [1] \"Italy\" #>  #> $`Ibaizabal Ibaia` #> [1] \"France\" #>  #> $`Rio Agüera O Mayor` #> integer(0) #>  #> $`Rio Ason` #> integer(0) #>  #> $`Rio Miera` #> integer(0) #>  #> $`Rio Pas` #> integer(0) #>  #> $`Rio Saja` #> [1] \"Italy\" #>  #> $`Rio Besaya` #> integer(0) #>  #> $`Rio Nansa` #> integer(0) #>  #> $`Rio Deva` #> integer(0) #>  #> $`Rio Cares` #> integer(0) #>  #> $`Rio Sella` #> integer(0) #>  #> $`Rio Piloña` #> integer(0) #>  #> $`Rio Nalon` #> integer(0) #>  #> $`Rio Narcea` #> integer(0) #>  #> $`Rio Pigüeña` #> [1] \"Portugal\" #>  #> $`Rio Nora` #> integer(0) #>  #> $`Rio Trubia` #> [1] \"France\" #>  #> $`Rio Esva` #> integer(0) #>  #> $`Rio Barcena` #> integer(0) #>  #> $`Rio Navia` #> integer(0) #>  #> $`Rio Navia` #> integer(0) #>  #> $`Rio Navia` #> integer(0) #>  #> $`Rio Navia` #> integer(0) #>  #> $`Rio Navia` #> integer(0) #>  #> $`Rio Agueira` #> integer(0) #>  #> $`Rio Eo` #> integer(0) #>  #> $`Rio Masma` #> integer(0) #>  #> $`Rio Landro` #> integer(0) #>  #> $`Rio Sor` #> integer(0) #>  #> $`Rio Mera` #> integer(0) #>  #> $`Rio Eume` #> integer(0) #>  #> $`Rio Eume` #> integer(0) #>  #> $`Rio Eume` #> integer(0) #>  #> $`Rio Mandeo` #> integer(0) #>  #> $`Rio Mero` #> integer(0) #>  #> $`Rio Anllons` #> integer(0) #>  #> $`Rio Xallas` #> integer(0) #>  #> $`Rio Xallas` #> integer(0) #>  #> $`Rio Xallas` #> integer(0) #>  #> $`Rio Tambre` #> integer(0) #>  #> $`Rio Ulla` #> integer(0) #>  #> $`Rio Ulla` #> integer(0) #>  #> $`Rio Ulla` #> integer(0) #>  #> $`Rio Arnego` #> integer(0) #>  #> $`Rio Arnego` #> integer(0) #>  #> $`Rio Umia` #> integer(0) #>  #> $`Rio Lerez` #> integer(0) #>  #> $`Rio Verdugo` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Tea` #> integer(0) #>  #> $`Rio Arnoia` #> integer(0) #>  #> $`Rio Avia` #> integer(0) #>  #> $`Rio Avia` #> integer(0) #>  #> $`Rio Avia` #> integer(0) #>  #> $`Rio Sil` #> integer(0) #>  #> $`Rio Sil` #> integer(0) #>  #> $`Rio Sil` #> integer(0) #>  #> $`Rio Sil` #> integer(0) #>  #> $`Rio Sil` #> integer(0) #>  #> $`Rio Cabe` #> integer(0) #>  #> $`Rio Mao` #> integer(0) #>  #> $`Rio Bibei` #> integer(0) #>  #> $`Rio Bibei` #> integer(0) #>  #> $`Rio Bibei` #> integer(0) #>  #> $`Rio Xares` #> integer(0) #>  #> $`Rio Xares` #> integer(0) #>  #> $`Rio Xares` #> integer(0) #>  #> $`Rio Conso` #> integer(0) #>  #> $`Rio Conso` #> integer(0) #>  #> $`Rio Camba` #> integer(0) #>  #> $`Rio Camba` #> integer(0) #>  #> $`Rio Camba` #> integer(0) #>  #> $`Rio Camba` #> integer(0) #>  #> $`Rio Selmo` #> [1] \"Italy\" #>  #> $`Rio Burbia` #> integer(0) #>  #> $`Rio Boeza` #> integer(0) #>  #> $`Rio Neira` #> integer(0) #>  #> $`Rio Ladra` #> integer(0) #>  #> $`Rio Parga` #> integer(0) #>  #> $`Rio Limia` #> integer(0) #>  #> $`Rio Limia` #> integer(0) #>  #> $`Rio Limia` #> integer(0) #>  #> $`Rio Limia` #> [1] \"Portugal\" #>  #> $`Rio Salas` #> integer(0) #>"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_crs.html","id":null,"dir":"Reference","previous_headings":"","what":"Check CRS of a table — ddbs_crs","title":"Check CRS of a table — ddbs_crs","text":"Check CRS table","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_crs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check CRS of a table — ddbs_crs","text":"","code":"ddbs_crs(conn, name, crs_column = \"crs_duckspatial\")"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_crs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check CRS of a table — ddbs_crs","text":"conn connection object DuckDB database name character string length one specifying name table, character string length two specifying schema table names. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector)","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_crs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check CRS of a table — ddbs_crs","text":"CRS object","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_crs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check CRS of a table — ddbs_crs","text":"","code":"if (FALSE) { # interactive() ## load packages library(duckdb) library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data countries_sf <- st_read(system.file(\"spatial/countries.geojson\", package = \"duckspatial\"))  ## store in duckdb ddbs_write_vector(conn, countries_sf, \"countries\")  ## check CRS ddbs_crs(conn, \"countries\") }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_difference.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates the difference of two geometries — ddbs_difference","title":"Calculates the difference of two geometries — ddbs_difference","text":"Calculates geometric difference two geometries, returns sf object creates new table","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_difference.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates the difference of two geometries — ddbs_difference","text":"","code":"ddbs_difference(   x,   y,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_difference.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates the difference of two geometries — ddbs_difference","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y table geometry column within DuckDB database conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_difference.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates the difference of two geometries — ddbs_difference","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_difference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates the difference of two geometries — ddbs_difference","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data countries_sf <- st_read(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) argentina_sf <- st_read(system.file(\"spatial/argentina.geojson\", package = \"duckspatial\"))  ## store in duckdb ddbs_write_vector(conn, countries_sf, \"countries\") ddbs_write_vector(conn, argentina_sf, \"argentina\")  ## difference with a connection ddbs_difference(\"countries\", \"argentina\", conn)  ## difference without a connection ddbs_difference(countries_sf, argentina_sf) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_disjoint.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial disjoint predicate — ddbs_disjoint","title":"Spatial disjoint predicate — ddbs_disjoint","text":"Tests geometries x disjoint geometries y. Returns TRUE geometries points common.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_disjoint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial disjoint predicate — ddbs_disjoint","text":"","code":"ddbs_disjoint(   x,   y,   conn = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_disjoint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial disjoint predicate — ddbs_disjoint","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. id_x Character; optional name column x whose values used name list elements. NULL, integer row numbers x used. id_y Character; optional name column y whose values replace integer indices returned element list. sparse logical value. TRUE, returns sparse index list. FALSE, returns dense logical matrix. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_disjoint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial disjoint predicate — ddbs_disjoint","text":"list element contains indices (IDs) geometries y disjoint corresponding geometry x. See ddbs_predicate() details.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_disjoint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial disjoint predicate — ddbs_disjoint","text":"convenience wrapper around ddbs_predicate() predicate = \"disjoint\".","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_disjoint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial disjoint predicate — ddbs_disjoint","text":"","code":"## load packages library(dplyr) library(duckspatial) library(sf)  ## read countries data, and rivers countries_sf <- read_sf(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\")) rivers_sf <- st_read(system.file(\"spatial/rivers.geojson\", package = \"duckspatial\")) |>   st_transform(st_crs(countries_sf)) #> Reading layer `rivers' from data source  #>   `/home/runner/work/_temp/Library/duckspatial/spatial/rivers.geojson'  #>   using driver `GeoJSON' #> Simple feature collection with 100 features and 1 field #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 2766878 ymin: 2222357 xmax: 3578648 ymax: 2459939 #> Projected CRS: ETRS89-extended / LAEA Europe  ddbs_disjoint(countries_sf, rivers_sf, id_x = \"NAME_ENGL\") #> ✔ Query successful #> $Spain #> integer(0) #>  #> $France #>  [1]   1   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20 #> [20]  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39 #> [39]  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58 #> [58]  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77 #> [77]  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  96 #> [96]  97  98  99 100 #>  #> $Italy #>   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18 #>  [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36 #>  [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54 #>  [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72 #>  [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90 #>  [91]  91  92  93  94  95  96  97  98  99 100 #>  #> $Portugal #>  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19 #> [20]  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38 #> [39]  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57 #> [58]  58  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77 #> [77]  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93  94  95  97 #> [96]  98  99 100 #>"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns the distance between two geometries — ddbs_distance","title":"Returns the distance between two geometries — ddbs_distance","text":"Returns planar haversine distance two geometries, returns data.frame object creates new table DuckDB database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns the distance between two geometries — ddbs_distance","text":"","code":"ddbs_distance(x, y, dist_type = \"haversine\", conn = NULL, quiet = FALSE)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns the distance between two geometries — ddbs_distance","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. dist_type String. One c(\"planar\", \"haversine\"). Defaults \"haversine\" returns distance meters, input expected WGS84 (EPSG:4326) coordinates. option \"haversine\" accepts POINT geometries. dist_type = \"planar\", distances estimates unit coordinate reference system (CRS) input. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns the distance between two geometries — ddbs_distance","text":"data.frame object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns the distance between two geometries — ddbs_distance","text":"","code":"if (FALSE) { # \\dontrun{ # load packages library(duckspatial) library(sf)  # create points data n <- 10 points_sf <- data.frame(     id = 1:n,     x = runif(n, min = -180, max = 180),     y = runif(n, min = -90, max = 90) ) |>     sf::st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)  # option 1: passing sf objects output1 <- duckspatial::ddbs_distance(     x = points_sf,     y = points_sf,     dist_type = \"haversine\" )  head(output1)   ## option 2: passing the names of tables in a duckdb db and output as sf  # creates a duckdb conn <- duckspatial::ddbs_create_conn()  # write sf to duckdb ddbs_write_vector(conn, points_sf, \"points\", overwrite = TRUE)  output2 <- ddbs_distance(     conn = conn,     x = \"points\",     y = \"points\",     dist_type = \"haversine\" ) head(output2)  } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_drivers.html","id":null,"dir":"Reference","previous_headings":"","what":"Get list of GDAL drivers and file formats — ddbs_drivers","title":"Get list of GDAL drivers and file formats — ddbs_drivers","text":"Get list GDAL drivers file formats","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_drivers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get list of GDAL drivers and file formats — ddbs_drivers","text":"","code":"ddbs_drivers(conn)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_drivers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get list of GDAL drivers and file formats — ddbs_drivers","text":"conn connection object DuckDB database","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_drivers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get list of GDAL drivers and file formats — ddbs_drivers","text":"data.frame","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_drivers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get list of GDAL drivers and file formats — ddbs_drivers","text":"","code":"if (FALSE) { # interactive() ## load packages library(duckdb) library(duckspatial)  ## database setup conn <- dbConnect(duckdb()) ddbs_install(conn) ddbs_load(conn)  ## check drivers ddbs_drivers(conn) }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_envelope.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns the envelope (bounding box) of geometries — ddbs_envelope","title":"Returns the envelope (bounding box) of geometries — ddbs_envelope","text":"Returns minimum bounding rectangle (envelope) geometries sf object DuckDB table. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_envelope.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns the envelope (bounding box) of geometries — ddbs_envelope","text":"","code":"ddbs_envelope(   x,   by_feature = FALSE,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_envelope.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns the envelope (bounding box) of geometries — ddbs_envelope","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. by_feature Logical. TRUE, returns one envelope per feature. FALSE (default), returns single envelope geometries combined. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_envelope.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns the envelope (bounding box) of geometries — ddbs_envelope","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_envelope.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns the envelope (bounding box) of geometries — ddbs_envelope","text":"ST_Envelope returns minimum bounding rectangle (MBR) geometry polygon. points lines, creates rectangular polygon encompasses geometry. polygons, returns smallest rectangle contains entire polygon. by_feature = FALSE, geometries combined single envelope returned encompasses entire dataset.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_envelope.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns the envelope (bounding box) of geometries — ddbs_envelope","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # read data argentina_sf <- st_read(system.file(\"spatial/argentina.geojson\", package = \"duckspatial\"))  # input as sf, and output as sf env <- ddbs_envelope(x = argentina_sf, by_feature = TRUE)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  # store in duckdb ddbs_write_vector(conn, argentina_sf, \"argentina\")  # envelope for each feature env <- ddbs_envelope(\"argentina\", conn, by_feature = TRUE)  # single envelope for entire dataset env_all <- ddbs_envelope(\"argentina\", conn, by_feature = FALSE)  # create a new table with envelopes ddbs_envelope(\"argentina\", conn, name = \"argentina_bbox\", by_feature = TRUE) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_equals.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial equals predicate — ddbs_equals","title":"Spatial equals predicate — ddbs_equals","text":"Tests geometries x spatially equal geometries y. Returns TRUE geometries topologically equivalent (shape location).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_equals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial equals predicate — ddbs_equals","text":"","code":"ddbs_equals(   x,   y,   conn = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_equals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial equals predicate — ddbs_equals","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. id_x Character; optional name column x whose values used name list elements. NULL, integer row numbers x used. id_y Character; optional name column y whose values replace integer indices returned element list. sparse logical value. TRUE, returns sparse index list. FALSE, returns dense logical matrix. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_equals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial equals predicate — ddbs_equals","text":"list element contains indices (IDs) geometries y equal corresponding geometry x. See ddbs_predicate() details.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_equals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial equals predicate — ddbs_equals","text":"convenience wrapper around ddbs_predicate() predicate = \"equals\".","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_equals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial equals predicate — ddbs_equals","text":"","code":"## load packages library(dplyr) library(duckspatial) library(sf)  ## read countries data, and rivers countries_sf <- read_sf(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\"))  ddbs_equals(countries_sf, countries_sf, id_x = \"NAME_ENGL\") #> ✔ Query successful #> $Spain #> [1] 1 #>  #> $France #> [1] 2 #>  #> $Italy #> [1] 3 #>  #> $Portugal #> [1] 4 #>"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs spatial filter of two geometries — ddbs_filter","title":"Performs spatial filter of two geometries — ddbs_filter","text":"Filters data spatially based spatial predicate","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs spatial filter of two geometries — ddbs_filter","text":"","code":"ddbs_filter(   x,   y,   predicate = \"intersects\",   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   distance = NULL,   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs spatial filter of two geometries — ddbs_filter","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y Y table geometry column within DuckDB database predicate geometry predicate function. Defaults intersects, wrapper ST_Intersects. See details options. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. distance numeric value specifying distance ST_DWithin. Units correspond coordinate system geometry (e.g. degrees meters) overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_filter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs spatial filter of two geometries — ddbs_filter","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_filter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Performs spatial filter of two geometries — ddbs_filter","text":"Spatial Join Predicates: spatial predicate really just function evaluates spatial relation two geometries returns true false, e.g., “contain b” “within distance x b”. quick overview commonly used ones, taking two geometries b: \"ST_Intersects\": Whether intersects b \"ST_Contains\": Whether contains b \"ST_ContainsProperly\": Whether contains b without b touching 's boundary \"ST_Within\": Whether within b \"ST_Overlaps\": Whether overlaps b \"ST_Touches\": Whether touches b \"ST_Equals\": Whether equal b \"ST_Crosses\": Whether crosses b \"ST_Covers\": Whether covers b \"ST_CoveredBy\": Whether covered b \"ST_DWithin\": x)\tWhether within distance x b","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_filter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs spatial filter of two geometries — ddbs_filter","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data countries_sf <- st_read(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) argentina_sf <- st_read(system.file(\"spatial/argentina.geojson\", package = \"duckspatial\"))  ## store in duckdb ddbs_write_vector(conn, countries_sf, \"countries\") ddbs_write_vector(conn, argentina_sf, \"argentina\")  ## filter countries touching argentina ddbs_filter(conn = conn, \"countries\", \"argentina\", predicate = \"touches\")  ## filter without using a connection ddbs_filter(countries_sf, argentina_sf, predicate = \"touches\") } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_flip.html","id":null,"dir":"Reference","previous_headings":"","what":"Flip geometries horizontally or vertically — ddbs_flip","title":"Flip geometries horizontally or vertically — ddbs_flip","text":"Flips (reflects) geometries around centroid. Returns result sf object creates new table database. function equivalent terra::flip().","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_flip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flip geometries horizontally or vertically — ddbs_flip","text":"","code":"ddbs_flip(   x,   direction = c(\"horizontal\", \"vertical\"),   by_feature = FALSE,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_flip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flip geometries horizontally or vertically — ddbs_flip","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. direction character string specifying flip direction: \"horizontal\" (default) \"vertical\". Horizontal flips across Y-axis (left-right), vertical flips across X-axis (top-bottom) by_feature Logical. TRUE, geometric operation applied separately geometry. FALSE (default), geometric operation applied data whole. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_flip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Flip geometries horizontally or vertically — ddbs_flip","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_flip.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Flip geometries horizontally or vertically — ddbs_flip","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_sf <- st_read(system.file(\"spatial/argentina.geojson\", package = \"duckspatial\"))  ## store in duckdb ddbs_write_vector(conn, argentina_sf, \"argentina\")  ## flip all features together as a whole (default) ddbs_flip(conn = conn, \"argentina\", direction = \"horizontal\", by_feature = FALSE)  ## flip each feature independently ddbs_flip(conn = conn, \"argentina\", direction = \"horizontal\", by_feature = TRUE)  ## flip without using a connection ddbs_flip(argentina_sf, direction = \"horizontal\") } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_glimpse.html","id":null,"dir":"Reference","previous_headings":"","what":"Check first rows of the data — ddbs_glimpse","title":"Check first rows of the data — ddbs_glimpse","text":"Check first rows data","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_glimpse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check first rows of the data — ddbs_glimpse","text":"","code":"ddbs_glimpse(   conn,   name,   crs = NULL,   crs_column = \"crs_duckspatial\",   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_glimpse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check first rows of the data — ddbs_glimpse","text":"conn connection object DuckDB database name character string length one specifying name table, character string length two specifying schema table names. crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_glimpse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check first rows of the data — ddbs_glimpse","text":"sf object","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_glimpse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check first rows of the data — ddbs_glimpse","text":"","code":"if (FALSE) { # interactive() library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_sf <- st_read(system.file(\"spatial/argentina.geojson\", package = \"duckspatial\"))  ## store in duckdb ddbs_write_vector(conn, argentina_sf, \"argentina\")  ddbs_glimpse(conn, \"argentina\") }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_install.html","id":null,"dir":"Reference","previous_headings":"","what":"Checks and installs the Spatial extension — ddbs_install","title":"Checks and installs the Spatial extension — ddbs_install","text":"Checks spatial extension available, installs DuckDB database","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_install.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checks and installs the Spatial extension — ddbs_install","text":"","code":"ddbs_install(conn, upgrade = FALSE, quiet = FALSE)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_install.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Checks and installs the Spatial extension — ddbs_install","text":"conn connection object DuckDB database upgrade TRUE, upgrades DuckDB extension latest version quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_install.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Checks and installs the Spatial extension — ddbs_install","text":"TRUE (invisibly) successful installation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_install.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Checks and installs the Spatial extension — ddbs_install","text":"","code":"## load packages library(duckspatial) library(duckdb)  # connect to in memory database conn <- duckdb::dbConnect(duckdb::duckdb())  # install the spatial extension ddbs_install(conn) #> ℹ spatial extension version <2f2668d> is already installed in this database  # disconnect from db duckdb::dbDisconnect(conn)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_interpolate_aw.html","id":null,"dir":"Reference","previous_headings":"","what":"Areal-Weighted Interpolation using DuckDB — ddbs_interpolate_aw","title":"Areal-Weighted Interpolation using DuckDB — ddbs_interpolate_aw","text":"Transfers attribute data source spatial layer target spatial layer based area overlap geometries. function executes spatial calculations within DuckDB, enabling efficient processing large datasets without loading geometries R memory.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_interpolate_aw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Areal-Weighted Interpolation using DuckDB — ddbs_interpolate_aw","text":"","code":"ddbs_interpolate_aw(   target,   source,   tid,   sid,   extensive = NULL,   intensive = NULL,   weight = \"sum\",   output = \"sf\",   keep_NA = TRUE,   na.rm = FALSE,   join_crs = NULL,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_interpolate_aw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Areal-Weighted Interpolation using DuckDB — ddbs_interpolate_aw","text":"target sf object name persistent table DuckDB connection representing destination geometries. source sf object name persistent table DuckDB connection containing data interpolated. tid Character. name column target uniquely identifies features. sid Character. name column source uniquely identifies features. extensive Character vector. Names columns source treated spatially extensive (e.g., population counts). intensive Character vector. Names columns source treated spatially intensive (e.g., population density). weight Character. Determines denominator calculation extensive variables. Either \"sum\" (default) \"total\". See Mass Preservation Details. output Character. One \"sf\" (default) \"tibble\". \"sf\": result includes geometry column target. \"tibble\": result excludes geometry column. significantly faster consumes less storage. Note: argument also controls schema created table name provided. keep_NA Logical. TRUE (default), returns features target, even overlap source (values NA). FALSE, performs inner join, dropping non-overlapping target features. na.rm Logical. TRUE, source features NA values interpolated variables completely removed calculation (area calculations behave polygon exist). Defaults FALSE. join_crs Numeric Character (optional). EPSG code WKT CRS use area calculations. provided, target source transformed CRS within database interpolation. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_interpolate_aw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Areal-Weighted Interpolation using DuckDB — ddbs_interpolate_aw","text":"name NULL (default): Returns sf object (output=\"sf\") tibble (output=\"tibble\"). name provided: Returns TRUE invisibly creates persistent table DuckDB database. output=\"sf\", table includes geometry column. output=\"tibble\", table excludes geometry column (pure attributes).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_interpolate_aw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Areal-Weighted Interpolation using DuckDB — ddbs_interpolate_aw","text":"Areal-weighted interpolation used source target geometries incongruent (align). relies assumption uniform distribution: values source polygons assumed spread evenly across polygon's area. Coordinate Systems: Area calculations highly sensitive Coordinate Reference System (CRS). function can run geographic coordinates (lon/lat), strongly recommended use projected CRS (e.g., EPSG:3857, UTM, Albers) ensure accurate area measurements. Use join_crs argument project data --fly interpolation. Extensive vs. Intensive Variables: Extensive variables counts absolute amounts (e.g., total population, number voters). source polygon split, value divided proportionally area. Intensive variables ratios, rates, densities (e.g., population density, cancer rates). source polygon split, value remains constant piece. Mass Preservation (weight argument): extensive variables, choice weight determines denominator used calculations: \"sum\" (default): denominator sum overlapping areas source feature. preserves \"mass\" variable relative target's coverage. target polygons completely cover source polygon, data technically \"lost\" falls outside target area. matches areal::aw_interpolate(weight=\"sum\"). \"total\": denominator full geometric area source feature. assumes source value distributed entire source polygon. target covers 50% source, 50% value transferred. strictly mass-preserving relative source. matches sf::st_interpolate_aw(extensive=TRUE). Note: Intensive variables always calculated using \"sum\" logic (averaging based intersection areas) regardless parameter.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_interpolate_aw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Areal-Weighted Interpolation using DuckDB — ddbs_interpolate_aw","text":"Prener, C. Revord, C. (2019). areal: R package areal weighted interpolation. Journal Open Source Software, 4(37), 1221. Available : https://doi.org/10.21105/joss.01221","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_interpolate_aw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Areal-Weighted Interpolation using DuckDB — ddbs_interpolate_aw","text":"","code":"# \\donttest{ library(sf)  # 1. Prepare Data # Load NC counties (Source) and project to Albers (EPSG:5070) nc <- st_read(system.file(\"shape/nc.shp\", package = \"sf\"), quiet = TRUE) nc <- st_transform(nc, 5070) nc$sid <- seq_len(nrow(nc)) # Create Source ID  # Create a target grid g <- st_make_grid(nc, n = c(10, 5)) g_sf <- st_as_sf(g) g_sf$tid <- seq_len(nrow(g_sf)) # Create Target ID  # 2. Extensive Interpolation (Counts) # Use weight = \"total\" for strict mass preservation (e.g., total births) res_ext <- ddbs_interpolate_aw(   target = g_sf, source = nc,   tid = \"tid\", sid = \"sid\",   extensive = \"BIR74\",   weight = \"total\" ) #> ✔ Query successful  # Check mass preservation sum(res_ext$BIR74, na.rm = TRUE) / sum(nc$BIR74) # Should be ~1 #> [1] 1  # 3. Intensive Interpolation (Density/Rates) # Calculates area-weighted average (e.g., assumption of uniform density) res_int <- ddbs_interpolate_aw(   target = g_sf, source = nc,   tid = \"tid\", sid = \"sid\",   intensive = \"BIR74\" ) #> ✔ Query successful  # 4. Quick Visualization par(mfrow = c(1, 2)) plot(res_ext[\"BIR74\"], main = \"Extensive (Total Count)\", border = NA)  plot(res_int[\"BIR74\"], main = \"Intensive (Weighted Avg)\", border = NA)  # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersection.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates the intersection of two geometries — ddbs_intersection","title":"Calculates the intersection of two geometries — ddbs_intersection","text":"Calculates intersection two geometries, return sf object creates new table","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates the intersection of two geometries — ddbs_intersection","text":"","code":"ddbs_intersection(   x,   y,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates the intersection of two geometries — ddbs_intersection","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y table geometry column within DuckDB database conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersection.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates the intersection of two geometries — ddbs_intersection","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersection.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates the intersection of two geometries — ddbs_intersection","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data countries_sf <- st_read(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) argentina_sf <- st_read(system.file(\"spatial/argentina.geojson\", package = \"duckspatial\"))  ## store in duckdb ddbs_write_vector(conn, countries_sf, \"countries\") ddbs_write_vector(conn, argentina_sf, \"argentina\")  ## intersection inside the connection ddbs_intersection(\"countries\", \"argentina\", conn)  ## intersection without using a connection ddbs_intersection(countries_sf, argentina_sf) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersects.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial intersects predicate — ddbs_intersects","title":"Spatial intersects predicate — ddbs_intersects","text":"Tests geometries x intersect geometries y. Returns TRUE geometries share least one point common.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial intersects predicate — ddbs_intersects","text":"","code":"ddbs_intersects(   x,   y,   conn = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial intersects predicate — ddbs_intersects","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. id_x Character; optional name column x whose values used name list elements. NULL, integer row numbers x used. id_y Character; optional name column y whose values replace integer indices returned element list. sparse logical value. TRUE, returns sparse index list. FALSE, returns dense logical matrix. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial intersects predicate — ddbs_intersects","text":"list element contains indices (IDs) geometries y intersect corresponding geometry x. See ddbs_predicate() details.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersects.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial intersects predicate — ddbs_intersects","text":"convenience wrapper around ddbs_predicate() predicate = \"intersects\".","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersects.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial intersects predicate — ddbs_intersects","text":"","code":"## load packages library(dplyr) library(duckspatial) library(sf)  ## read countries data, and rivers countries_sf <- read_sf(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\")) rivers_sf <- st_read(system.file(\"spatial/rivers.geojson\", package = \"duckspatial\")) |>   st_transform(st_crs(countries_sf)) #> Reading layer `rivers' from data source  #>   `/home/runner/work/_temp/Library/duckspatial/spatial/rivers.geojson'  #>   using driver `GeoJSON' #> Simple feature collection with 100 features and 1 field #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 2766878 ymin: 2222357 xmax: 3578648 ymax: 2459939 #> Projected CRS: ETRS89-extended / LAEA Europe  ddbs_intersects(countries_sf, rivers_sf, id_x = \"NAME_ENGL\") #> ✔ Query successful #> $Spain #>   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18 #>  [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36 #>  [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54 #>  [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72 #>  [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90 #>  [91]  91  92  93  94  95  96  97  98  99 100 #>  #> $France #> [1] 2 #>  #> $Italy #> integer(0) #>  #> $Portugal #> [1] 59 96 #>"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersects_extent.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial intersects extent predicate — ddbs_intersects_extent","title":"Spatial intersects extent predicate — ddbs_intersects_extent","text":"Tests bounding box geometries x intersect bounding box geometries y. Returns TRUE extents (bounding boxes) overlap. faster full geometry intersection less precise.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersects_extent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial intersects extent predicate — ddbs_intersects_extent","text":"","code":"ddbs_intersects_extent(   x,   y,   conn = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersects_extent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial intersects extent predicate — ddbs_intersects_extent","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. id_x Character; optional name column x whose values used name list elements. NULL, integer row numbers x used. id_y Character; optional name column y whose values replace integer indices returned element list. sparse logical value. TRUE, returns sparse index list. FALSE, returns dense logical matrix. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersects_extent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial intersects extent predicate — ddbs_intersects_extent","text":"list element contains indices (IDs) geometries y whose bounding box intersects bounding box corresponding geometry x. See ddbs_predicate() details.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersects_extent.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial intersects extent predicate — ddbs_intersects_extent","text":"convenience wrapper around ddbs_predicate() predicate = \"intersects_extent\".","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_intersects_extent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial intersects extent predicate — ddbs_intersects_extent","text":"","code":"## load packages library(dplyr) library(duckspatial) library(sf)  ## read countries data, and rivers countries_sf <- read_sf(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\")) rivers_sf <- st_read(system.file(\"spatial/rivers.geojson\", package = \"duckspatial\")) |>   st_transform(st_crs(countries_sf)) #> Reading layer `rivers' from data source  #>   `/home/runner/work/_temp/Library/duckspatial/spatial/rivers.geojson'  #>   using driver `GeoJSON' #> Simple feature collection with 100 features and 1 field #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 2766878 ymin: 2222357 xmax: 3578648 ymax: 2459939 #> Projected CRS: ETRS89-extended / LAEA Europe  # Fast bounding box intersection check ddbs_intersects_extent(countries_sf, rivers_sf, id_x = \"NAME_ENGL\") #> ✔ Query successful #> $Spain #>   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18 #>  [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36 #>  [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54 #>  [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72 #>  [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90 #>  [91]  91  92  93  94  95  96  97  98  99 100 #>  #> $France #>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 #>  #> $Italy #> integer(0) #>  #> $Portugal #>  [1]  59  66  67  78  84  86  87  88  89  96  97  98  99 100 #>"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_simple.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if geometries are simple — ddbs_is_simple","title":"Check if geometries are simple — ddbs_is_simple","text":"Checks geometries simple (self-intersections) DuckDB table using spatial extension. Returns result sf object boolean simplicity column creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_simple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if geometries are simple — ddbs_is_simple","text":"","code":"ddbs_is_simple(   x,   conn = NULL,   name = NULL,   new_column = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_simple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if geometries are simple — ddbs_is_simple","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object new_column Name new column create input data. NULL, function return vector result crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_simple.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if geometries are simple — ddbs_is_simple","text":"vector, sf object simplicity information TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_simple.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if geometries are simple — ddbs_is_simple","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_sf <- st_read(system.file(\"spatial/argentina.geojson\", package = \"duckspatial\"))  ## store in duckdb ddbs_write_vector(conn, argentina_sf, \"argentina\")  ## check simplicity ddbs_is_simple(\"argentina\", conn)  ## check simplicity without using a connection ddbs_is_simple(argentina_sf) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_valid.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if geometries are valid — ddbs_is_valid","title":"Check if geometries are valid — ddbs_is_valid","text":"Checks validity geometries DuckDB table using spatial extension. Returns result sf object boolean validity column creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_valid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if geometries are valid — ddbs_is_valid","text":"","code":"ddbs_is_valid(   x,   conn = NULL,   name = NULL,   new_column = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_valid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if geometries are valid — ddbs_is_valid","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object new_column Name new column create input data. NULL, function return vector result crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_valid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if geometries are valid — ddbs_is_valid","text":"vector, sf object validity information TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_valid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if geometries are valid — ddbs_is_valid","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_sf <- st_read(system.file(\"spatial/argentina.geojson\", package = \"duckspatial\"))  ## store in duckdb ddbs_write_vector(conn, argentina_sf, \"argentina\")  ## check validity ddbs_is_valid(\"argentina\", conn)  ## check validity without using a connection ddbs_is_valid(argentina_sf) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_within_distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Within Distance predicate — ddbs_is_within_distance","title":"Within Distance predicate — ddbs_is_within_distance","text":"Tests geometries x within specified distance y. Returns TRUE geometries within distance.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_within_distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Within Distance predicate — ddbs_is_within_distance","text":"","code":"ddbs_is_within_distance(   x,   y,   distance = NULL,   conn = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_within_distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Within Distance predicate — ddbs_is_within_distance","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. distance numeric value specifying distance ST_DWithin. Units correspond coordinate system geometry (e.g. degrees meters) conn connection object DuckDB database. NULL, function runs temporary DuckDB database. id_x Character; optional name column x whose values used name list elements. NULL, integer row numbers x used. id_y Character; optional name column y whose values replace integer indices returned element list. sparse logical value. TRUE, returns sparse index list. FALSE, returns dense logical matrix. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_within_distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Within Distance predicate — ddbs_is_within_distance","text":"list element contains indices (IDs) geometries y touch corresponding geometry x. See ddbs_predicate() details.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_within_distance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Within Distance predicate — ddbs_is_within_distance","text":"convenience wrapper around ddbs_predicate() predicate = \"dwithin\".","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_is_within_distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Within Distance predicate — ddbs_is_within_distance","text":"","code":"## load packages library(dplyr) library(duckspatial) library(sf)  ## read countries data, and rivers countries_sf <- read_sf(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) countries_filter_sf <- countries_sf |> filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\"))  ## check countries within 1 degree of distance ddbs_is_within_distance(countries_filter_sf, countries_sf, 1) #> ✔ Query successful #> [[1]] #> [1]   5  64  73  85 160 177 #>  #> [[2]] #>  [1]   5  19  60  64  71  79  85  90  91  96 173 178 206 #>  #> [[3]] #>  [1]   3  10  60  85  86  90  96 120 178 204 231 235 #>  #> [[4]] #> [1]  64 160 #>"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Performs spatial joins of two geometries — ddbs_join","title":"Performs spatial joins of two geometries — ddbs_join","text":"Performs spatial joins two geometries, returns sf object creates new table DuckDB database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Performs spatial joins of two geometries — ddbs_join","text":"","code":"ddbs_join(   x,   y,   join = \"intersects\",   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Performs spatial joins of two geometries — ddbs_join","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. join geometry predicate function. Defaults \"intersects\". See details options. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), return result sf object. crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_join.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Performs spatial joins of two geometries — ddbs_join","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_join.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Performs spatial joins of two geometries — ddbs_join","text":"Spatial Join Predicates: spatial predicate really just function evaluates spatial relation two geometries returns true false, e.g., “contain b” “within distance x b”. quick overview commonly used ones, taking two geometries b: \"ST_Intersects\": Whether intersects b \"ST_Contains\": Whether contains b \"ST_ContainsProperly\": Whether contains b without b touching 's boundary \"ST_Within\": Whether within b \"ST_Overlaps\": Whether overlaps b \"ST_Touches\": Whether touches b \"ST_Equals\": Whether equal b \"ST_Crosses\": Whether crosses b \"ST_Covers\": Whether covers b \"ST_CoveredBy\": Whether covered b \"ST_DWithin\": x)\tWhether within distance x b","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_join.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Performs spatial joins of two geometries — ddbs_join","text":"","code":"if (FALSE) { # \\dontrun{ # load packages library(duckspatial) library(sf)  # read polygons data countries_sf <- sf::st_read(system.file(\"spatial/countries.geojson\", package = \"duckspatial\"))  # create points data n <- 100 points_sf <- data.frame(     id = 1:n,     x = runif(n, min = -180, max = 180),     y = runif(n, min = -90, max = 90) ) |>     sf::st_as_sf(coords = c(\"x\", \"y\"), crs = 4326)    # option 1: passing sf objects output1 <- duckspatial::ddbs_join(     x = points_sf,     y = countries_sf,     join = \"within\" )  plot(output1[\"CNTR_NAME\"])   ## option 2: passing the names of tables in a duckdb db  # creates a duckdb conn <- duckspatial::ddbs_create_conn()  # write sf to duckdb ddbs_write_vector(conn, points_sf, \"points\", overwrite = TRUE) ddbs_write_vector(conn, countries_sf, \"countries\", overwrite = TRUE)  # spatial join output2 <- ddbs_join(     conn = conn,     x = \"points\",     y = \"countries\",     join = \"within\" )  plot(output2[\"CNTR_NAME\"])  } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_length.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates the length of geometries — ddbs_length","title":"Calculates the length of geometries — ddbs_length","text":"Calculates length geometries DuckDB table sf object Returns result sf object length column creates new table database. Note: Length units depend CRS input geometries (e.g., meters projected CRS, degrees geographic CRS).","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_length.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates the length of geometries — ddbs_length","text":"","code":"ddbs_length(   x,   conn = NULL,   name = NULL,   new_column = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_length.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates the length of geometries — ddbs_length","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object new_column Name new column create input data. NULL, function return vector result crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_length.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates the length of geometries — ddbs_length","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_length.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates the length of geometries — ddbs_length","text":"","code":"## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data rivers_sf <- st_read(system.file(\"spatial/rivers.geojson\", package = \"duckspatial\")) #> Reading layer `rivers' from data source  #>   `/home/runner/work/_temp/Library/duckspatial/spatial/rivers.geojson'  #>   using driver `GeoJSON' #> Simple feature collection with 100 features and 1 field #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 2766878 ymin: 2222357 xmax: 3578648 ymax: 2459939 #> Projected CRS: ETRS89-extended / LAEA Europe  ## store in duckdb ddbs_write_vector(conn, rivers_sf, \"rivers\") #> ✔ Table rivers successfully imported  ## calculate length (returns sf object with length column) ddbs_length(\"rivers\", conn) #>   [1]  34232.5206  29223.3570  22409.6485  27511.0723  14817.0831  40245.7499 #>   [7]  37421.6029  38787.4428  48753.1900  28956.8522  25919.4653  36597.7982 #>  [13]  36540.8556  49333.9047  55617.2751  41800.1935  38226.8089  53867.9142 #>  [19]  46182.5143  48424.6809  33236.1217 106821.9772  86470.3410  38880.7081 #>  [25]  39549.6752  26118.7215  17747.3794  16524.1617  22831.1831  53384.3893 #>  [31]  17442.6563   6789.6030  12059.9283  26856.6566  63429.8095  13767.1861 #>  [37]  23738.5150  35694.8459  19646.1745  10029.0179  13968.4457  41043.7032 #>  [43]  48714.4882  37133.2198  43436.8699  23642.8664  14212.4786   8445.8296 #>  [49]  97428.9007  33310.8820  10918.3777  73866.4040   5397.1562  31303.2187 #>  [55]  46783.2287  42065.3367  23982.1267   6855.8189  97390.1661  46243.7102 #>  [61]  15542.0333  31208.0987  30773.7428  40455.5784  10754.9779  39136.8449 #>  [67]  65827.5937   3693.5384  17902.1442   4323.2089 120300.4900   1959.2291 #>  [73]  60752.0324   9065.0840   6452.4055  42056.1917  18207.3070  39043.6943 #>  [79]  10745.6292  24112.5296   9128.6008  18416.8778  13895.3803  16908.1064 #>  [85]   6310.0966   4381.0841   7922.9705  12546.7703  11175.7684  31755.4344 #>  [91]  36926.0258  48195.5038  40373.2595  10658.1011  25550.2617  11961.7774 #>  [97]  39554.3265   4249.1463   8271.2878    619.3338  ## calculate length with custom column name ddbs_length(\"rivers\", conn, new_column = \"length_meters\") #> ✔ Query successful #> Simple feature collection with 100 features and 2 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 2766878 ymin: 2222357 xmax: 3578648 ymax: 2459939 #> Projected CRS: ETRS89-extended / LAEA Europe #> First 10 features: #>         RIVER_NAME length_meters                       geometry #> 1       Rio Garona      34232.52 LINESTRING (3563589 2240292... #> 2    Bidasoa Ibaia      29223.36 LINESTRING (3373540 2299136... #> 3     Baztan Ibaia      22409.65 LINESTRING (3373540 2299136... #> 4       Rio Urumea      27511.07 LINESTRING (3359001 2301989... #> 5       Oria Ibaia      14817.08 LINESTRING (3346144 2312252... #> 6       Oria Ibaia      40245.75 LINESTRING (3346144 2312252... #> 7      Urola Ibaia      37421.60 LINESTRING (3317563 2294789... #> 8       Deba Ibaia      38787.44 LINESTRING (3300422 2296792... #> 9      Rio Nervion      48753.19 LINESTRING (3263336 2300537... #> 10 Ibaizabal Ibaia      28956.85 LINESTRING (3299820 2310528...  ## create a new table with length calculations ddbs_length(\"rivers\", conn, name = \"rivers_with_length\") #>   [1]  34232.5206  29223.3570  22409.6485  27511.0723  14817.0831  40245.7499 #>   [7]  37421.6029  38787.4428  48753.1900  28956.8522  25919.4653  36597.7982 #>  [13]  36540.8556  49333.9047  55617.2751  41800.1935  38226.8089  53867.9142 #>  [19]  46182.5143  48424.6809  33236.1217 106821.9772  86470.3410  38880.7081 #>  [25]  39549.6752  26118.7215  17747.3794  16524.1617  22831.1831  53384.3893 #>  [31]  17442.6563   6789.6030  12059.9283  26856.6566  63429.8095  13767.1861 #>  [37]  23738.5150  35694.8459  19646.1745  10029.0179  13968.4457  41043.7032 #>  [43]  48714.4882  37133.2198  43436.8699  23642.8664  14212.4786   8445.8296 #>  [49]  97428.9007  33310.8820  10918.3777  73866.4040   5397.1562  31303.2187 #>  [55]  46783.2287  42065.3367  23982.1267   6855.8189  97390.1661  46243.7102 #>  [61]  15542.0333  31208.0987  30773.7428  40455.5784  10754.9779  39136.8449 #>  [67]  65827.5937   3693.5384  17902.1442   4323.2089 120300.4900   1959.2291 #>  [73]  60752.0324   9065.0840   6452.4055  42056.1917  18207.3070  39043.6943 #>  [79]  10745.6292  24112.5296   9128.6008  18416.8778  13895.3803  16908.1064 #>  [85]   6310.0966   4381.0841   7922.9705  12546.7703  11175.7684  31755.4344 #>  [91]  36926.0258  48195.5038  40373.2595  10658.1011  25550.2617  11961.7774 #>  [97]  39554.3265   4249.1463   8271.2878    619.3338  ## calculate length in a sf object (without a connection) ddbs_length(rivers_sf) #>   [1]  34232.5206  29223.3570  22409.6485  27511.0723  14817.0831  40245.7499 #>   [7]  37421.6029  38787.4428  48753.1900  28956.8522  25919.4653  36597.7982 #>  [13]  36540.8556  49333.9047  55617.2751  41800.1935  38226.8089  53867.9142 #>  [19]  46182.5143  48424.6809  33236.1217 106821.9772  86470.3410  38880.7081 #>  [25]  39549.6752  26118.7215  17747.3794  16524.1617  22831.1831  53384.3893 #>  [31]  17442.6563   6789.6030  12059.9283  26856.6566  63429.8095  13767.1861 #>  [37]  23738.5150  35694.8459  19646.1745  10029.0179  13968.4457  41043.7032 #>  [43]  48714.4882  37133.2198  43436.8699  23642.8664  14212.4786   8445.8296 #>  [49]  97428.9007  33310.8820  10918.3777  73866.4040   5397.1562  31303.2187 #>  [55]  46783.2287  42065.3367  23982.1267   6855.8189  97390.1661  46243.7102 #>  [61]  15542.0333  31208.0987  30773.7428  40455.5784  10754.9779  39136.8449 #>  [67]  65827.5937   3693.5384  17902.1442   4323.2089 120300.4900   1959.2291 #>  [73]  60752.0324   9065.0840   6452.4055  42056.1917  18207.3070  39043.6943 #>  [79]  10745.6292  24112.5296   9128.6008  18416.8778  13895.3803  16908.1064 #>  [85]   6310.0966   4381.0841   7922.9705  12546.7703  11175.7684  31755.4344 #>  [91]  36926.0258  48195.5038  40373.2595  10658.1011  25550.2617  11961.7774 #>  [97]  39554.3265   4249.1463   8271.2878    619.3338"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_list_tables.html","id":null,"dir":"Reference","previous_headings":"","what":"Check tables and schemas inside a database — ddbs_list_tables","title":"Check tables and schemas inside a database — ddbs_list_tables","text":"Check tables schemas inside database","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_list_tables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check tables and schemas inside a database — ddbs_list_tables","text":"","code":"ddbs_list_tables(conn)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_list_tables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check tables and schemas inside a database — ddbs_list_tables","text":"conn connection object DuckDB database","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_list_tables.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check tables and schemas inside a database — ddbs_list_tables","text":"data.frame","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_list_tables.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check tables and schemas inside a database — ddbs_list_tables","text":"","code":"if (FALSE) { # interactive() ## TODO 2+2 }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_load.html","id":null,"dir":"Reference","previous_headings":"","what":"Loads the Spatial extension — ddbs_load","title":"Loads the Spatial extension — ddbs_load","text":"Checks spatial extension installed, loads DuckDB database","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_load.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Loads the Spatial extension — ddbs_load","text":"","code":"ddbs_load(conn, quiet = FALSE)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_load.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Loads the Spatial extension — ddbs_load","text":"conn connection object DuckDB database quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_load.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Loads the Spatial extension — ddbs_load","text":"TRUE (invisibly) successful installation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_load.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Loads the Spatial extension — ddbs_load","text":"","code":"if (FALSE) { # interactive() ## load packages library(duckspatial) library(duckdb)  ## connect to in memory database conn <- duckdb::dbConnect(duckdb::duckdb())  ## install the spatial exntesion ddbs_install(conn) ddbs_load(conn)  ## disconnect from db duckdb::dbDisconnect(conn) }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_make_valid.html","id":null,"dir":"Reference","previous_headings":"","what":"Make invalid geometries valid — ddbs_make_valid","title":"Make invalid geometries valid — ddbs_make_valid","text":"Attempts make invalid geometries valid DuckDB table using spatial extension. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_make_valid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make invalid geometries valid — ddbs_make_valid","text":"","code":"ddbs_make_valid(   x,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_make_valid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make invalid geometries valid — ddbs_make_valid","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column Name column store CRS information. Default \"crs_duckspatial\". overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_make_valid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make invalid geometries valid — ddbs_make_valid","text":"sf object valid geometries TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_make_valid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make invalid geometries valid — ddbs_make_valid","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data countries_sf <- st_read(system.file(\"spatial/countries.geojson\", package = \"duckspatial\"))  ## store in duckdb ddbs_write_vector(conn, countries_sf, \"countries\")  ## make valid ddbs_make_valid(\"countries\", conn)  ## make valid without using a connection ddbs_make_valid(countries_sf) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_overlaps.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial overlaps predicate — ddbs_overlaps","title":"Spatial overlaps predicate — ddbs_overlaps","text":"Tests geometries x overlap geometries y. Returns TRUE geometries share points, intersection dimension geometries.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_overlaps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial overlaps predicate — ddbs_overlaps","text":"","code":"ddbs_overlaps(   x,   y,   conn = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_overlaps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial overlaps predicate — ddbs_overlaps","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. id_x Character; optional name column x whose values used name list elements. NULL, integer row numbers x used. id_y Character; optional name column y whose values replace integer indices returned element list. sparse logical value. TRUE, returns sparse index list. FALSE, returns dense logical matrix. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_overlaps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial overlaps predicate — ddbs_overlaps","text":"list element contains indices (IDs) geometries y overlap corresponding geometry x. See ddbs_predicate() details.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_overlaps.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial overlaps predicate — ddbs_overlaps","text":"convenience wrapper around ddbs_predicate() predicate = \"overlaps\".","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_overlaps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial overlaps predicate — ddbs_overlaps","text":"","code":"## load packages library(dplyr) library(duckspatial) library(sf)  ## read countries data, and rivers countries_sf <- read_sf(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\"))  spain_sf <- st_read(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"FI\")) #> Reading layer `countries' from data source  #>   `/home/runner/work/_temp/Library/duckspatial/spatial/countries.geojson'  #>   using driver `GeoJSON' #> Simple feature collection with 257 features and 6 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: -178.9125 ymin: -89.9 xmax: 180 ymax: 83.65187 #> Geodetic CRS:  WGS 84  ddbs_overlaps(countries_sf, spain_sf) #> ✔ Query successful #> [[1]] #> integer(0) #>  #> [[2]] #> integer(0) #>  #> [[3]] #> integer(0) #>  #> [[4]] #> integer(0) #>"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_predicate.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial predicate operations — ddbs_predicate","title":"Spatial predicate operations — ddbs_predicate","text":"Computes spatial relationships two geometry datasets using DuckDB's spatial extension. Returns list element corresponds row x, containing indices (IDs) rows y satisfy specified spatial predicate.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_predicate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial predicate operations — ddbs_predicate","text":"","code":"ddbs_predicate(   x,   y,   predicate = \"intersects\",   conn = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   distance = NULL,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_predicate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial predicate operations — ddbs_predicate","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. predicate geometry predicate function. Defaults intersects, wrapper ST_Intersects. See details options. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. id_x Character; optional name column x whose values used name list elements. NULL, integer row numbers x used. id_y Character; optional name column y whose values replace integer indices returned element list. sparse logical value. TRUE, returns sparse index list. FALSE, returns dense logical matrix. distance numeric value specifying distance ST_DWithin. Units correspond coordinate system geometry (e.g. degrees meters) quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_predicate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial predicate operations — ddbs_predicate","text":"list length equal number rows x. element contains: integer vector row indices y satisfy predicate corresponding geometry x, character vector id_y supplied. names list elements: integer row numbers x, values id_x provided. match x y returns NULL","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_predicate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial predicate operations — ddbs_predicate","text":"function provides unified interface spatial predicate operations DuckDB's spatial extension. performs pairwise comparisons geometries x y using specified predicate.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_predicate.html","id":"available-predicates","dir":"Reference","previous_headings":"","what":"Available Predicates","title":"Spatial predicate operations — ddbs_predicate","text":"intersects: Geometries share least one point covers: Geometry x completely covers geometry y touches: Geometries share boundary interiors intersect disjoint: Geometries points common within: Geometry x completely inside geometry y dwithin: Geometry x completely within distance geometry y contains: Geometry x completely contains geometry y overlaps: Geometries share points crosses: Geometries interior points common equals: Geometries spatially equal covered_by: Geometry x completely covered geometry y intersects_extent: Bounding boxes geometries intersect (faster less precise) contains_properly: Geometry x contains geometry y without boundary contact within_properly: Geometry x within geometry y without boundary contact x y DuckDB tables, automatically copied temporary -memory DuckDB database (unless connection supplied via conn). id_x id_y may used replace default integer indices values identifier column x y, respectively.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_predicate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial predicate operations — ddbs_predicate","text":"","code":"## Load packages library(duckspatial) library(dplyr) library(sf)  ## create in-memory DuckDB database conn <- ddbs_create_conn(dbdir = \"memory\")  ## read countries data, and rivers countries_sf <- read_sf(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\")) rivers_sf <- st_read(system.file(\"spatial/rivers.geojson\", package = \"duckspatial\")) |>   st_transform(st_crs(countries_sf)) #> Reading layer `rivers' from data source  #>   `/home/runner/work/_temp/Library/duckspatial/spatial/rivers.geojson'  #>   using driver `GeoJSON' #> Simple feature collection with 100 features and 1 field #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 2766878 ymin: 2222357 xmax: 3578648 ymax: 2459939 #> Projected CRS: ETRS89-extended / LAEA Europe  ## Store in DuckDB ddbs_write_vector(conn, countries_sf, \"countries\") #> ✔ Table countries successfully imported ddbs_write_vector(conn, rivers_sf, \"rivers\") #> ✔ Table rivers successfully imported  ## Example 1: Check which rivers intersect each country ddbs_predicate(countries_sf, rivers_sf, predicate = \"intersects\", conn) #> ✔ Query successful #> [[1]] #>   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18 #>  [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36 #>  [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54 #>  [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72 #>  [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90 #>  [91]  91  92  93  94  95  96  97  98  99 100 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> integer(0) #>  #> [[4]] #> [1] 59 96 #>   ## Example 2: Find neighboring countries ddbs_predicate(countries_sf, countries_sf, predicate = \"touches\",                id_x = \"NAME_ENGL\", id_y = \"NAME_ENGL\") #> ✔ Query successful #> $Spain #> [1] \"France\"   \"Portugal\" #>  #> $France #> [1] \"Spain\" \"Italy\" #>  #> $Italy #> [1] \"France\" #>  #> $Portugal #> [1] \"Spain\" #>   ## Example 3: Find rivers that don't intersect countries ddbs_predicate(countries_sf, rivers_sf, predicate = \"disjoint\",                id_x = \"NAME_ENGL\", id_y = \"RIVER_NAME\") #> ✔ Query successful #> $Spain #> integer(0) #>  #> $France #>  [1] \"Rio Garona\"         \"Baztan Ibaia\"       \"Rio Urumea\"         #>  [4] \"Oria Ibaia\"         \"Oria Ibaia\"         \"Urola Ibaia\"        #>  [7] \"Deba Ibaia\"         \"Rio Nervion\"        \"Ibaizabal Ibaia\"    #> [10] \"Rio Agüera O Mayor\" \"Rio Ason\"           \"Rio Miera\"          #> [13] \"Rio Pas\"            \"Rio Saja\"           \"Rio Besaya\"         #> [16] \"Rio Nansa\"          \"Rio Deva\"           \"Rio Cares\"          #> [19] \"Rio Sella\"          \"Rio Piloña\"         \"Rio Nalon\"          #> [22] \"Rio Narcea\"         \"Rio Pigüeña\"        \"Rio Nora\"           #> [25] \"Rio Trubia\"         \"Rio Esva\"           \"Rio Barcena\"        #> [28] \"Rio Navia\"          \"Rio Navia\"          \"Rio Navia\"          #> [31] \"Rio Navia\"          \"Rio Navia\"          \"Rio Agueira\"        #> [34] \"Rio Eo\"             \"Rio Masma\"          \"Rio Landro\"         #> [37] \"Rio Sor\"            \"Rio Mera\"           \"Rio Eume\"           #> [40] \"Rio Eume\"           \"Rio Eume\"           \"Rio Mandeo\"         #> [43] \"Rio Mero\"           \"Rio Anllons\"        \"Rio Xallas\"         #> [46] \"Rio Xallas\"         \"Rio Xallas\"         \"Rio Tambre\"         #> [49] \"Rio Ulla\"           \"Rio Ulla\"           \"Rio Ulla\"           #> [52] \"Rio Arnego\"         \"Rio Arnego\"         \"Rio Umia\"           #> [55] \"Rio Lerez\"          \"Rio Verdugo\"        \"Rio Miño\"           #> [58] \"Rio Miño\"           \"Rio Miño\"           \"Rio Miño\"           #> [61] \"Rio Miño\"           \"Rio Miño\"           \"Rio Miño\"           #> [64] \"Rio Miño\"           \"Rio Tea\"            \"Rio Arnoia\"         #> [67] \"Rio Avia\"           \"Rio Avia\"           \"Rio Avia\"           #> [70] \"Rio Sil\"            \"Rio Sil\"            \"Rio Sil\"            #> [73] \"Rio Sil\"            \"Rio Sil\"            \"Rio Cabe\"           #> [76] \"Rio Mao\"            \"Rio Bibei\"          \"Rio Bibei\"          #> [79] \"Rio Bibei\"          \"Rio Xares\"          \"Rio Xares\"          #> [82] \"Rio Xares\"          \"Rio Conso\"          \"Rio Conso\"          #> [85] \"Rio Camba\"          \"Rio Camba\"          \"Rio Camba\"          #> [88] \"Rio Camba\"          \"Rio Selmo\"          \"Rio Burbia\"         #> [91] \"Rio Boeza\"          \"Rio Neira\"          \"Rio Ladra\"          #> [94] \"Rio Parga\"          \"Rio Limia\"          \"Rio Limia\"          #> [97] \"Rio Limia\"          \"Rio Limia\"          \"Rio Salas\"          #>  #> $Italy #>   [1] \"Rio Garona\"         \"Bidasoa Ibaia\"      \"Baztan Ibaia\"       #>   [4] \"Rio Urumea\"         \"Oria Ibaia\"         \"Oria Ibaia\"         #>   [7] \"Urola Ibaia\"        \"Deba Ibaia\"         \"Rio Nervion\"        #>  [10] \"Ibaizabal Ibaia\"    \"Rio Agüera O Mayor\" \"Rio Ason\"           #>  [13] \"Rio Miera\"          \"Rio Pas\"            \"Rio Saja\"           #>  [16] \"Rio Besaya\"         \"Rio Nansa\"          \"Rio Deva\"           #>  [19] \"Rio Cares\"          \"Rio Sella\"          \"Rio Piloña\"         #>  [22] \"Rio Nalon\"          \"Rio Narcea\"         \"Rio Pigüeña\"        #>  [25] \"Rio Nora\"           \"Rio Trubia\"         \"Rio Esva\"           #>  [28] \"Rio Barcena\"        \"Rio Navia\"          \"Rio Navia\"          #>  [31] \"Rio Navia\"          \"Rio Navia\"          \"Rio Navia\"          #>  [34] \"Rio Agueira\"        \"Rio Eo\"             \"Rio Masma\"          #>  [37] \"Rio Landro\"         \"Rio Sor\"            \"Rio Mera\"           #>  [40] \"Rio Eume\"           \"Rio Eume\"           \"Rio Eume\"           #>  [43] \"Rio Mandeo\"         \"Rio Mero\"           \"Rio Anllons\"        #>  [46] \"Rio Xallas\"         \"Rio Xallas\"         \"Rio Xallas\"         #>  [49] \"Rio Tambre\"         \"Rio Ulla\"           \"Rio Ulla\"           #>  [52] \"Rio Ulla\"           \"Rio Arnego\"         \"Rio Arnego\"         #>  [55] \"Rio Umia\"           \"Rio Lerez\"          \"Rio Verdugo\"        #>  [58] \"Rio Miño\"           \"Rio Miño\"           \"Rio Miño\"           #>  [61] \"Rio Miño\"           \"Rio Miño\"           \"Rio Miño\"           #>  [64] \"Rio Miño\"           \"Rio Miño\"           \"Rio Tea\"            #>  [67] \"Rio Arnoia\"         \"Rio Avia\"           \"Rio Avia\"           #>  [70] \"Rio Avia\"           \"Rio Sil\"            \"Rio Sil\"            #>  [73] \"Rio Sil\"            \"Rio Sil\"            \"Rio Sil\"            #>  [76] \"Rio Cabe\"           \"Rio Mao\"            \"Rio Bibei\"          #>  [79] \"Rio Bibei\"          \"Rio Bibei\"          \"Rio Xares\"          #>  [82] \"Rio Xares\"          \"Rio Xares\"          \"Rio Conso\"          #>  [85] \"Rio Conso\"          \"Rio Camba\"          \"Rio Camba\"          #>  [88] \"Rio Camba\"          \"Rio Camba\"          \"Rio Selmo\"          #>  [91] \"Rio Burbia\"         \"Rio Boeza\"          \"Rio Neira\"          #>  [94] \"Rio Ladra\"          \"Rio Parga\"          \"Rio Limia\"          #>  [97] \"Rio Limia\"          \"Rio Limia\"          \"Rio Limia\"          #> [100] \"Rio Salas\"          #>  #> $Portugal #>  [1] \"Rio Garona\"         \"Bidasoa Ibaia\"      \"Baztan Ibaia\"       #>  [4] \"Rio Urumea\"         \"Oria Ibaia\"         \"Oria Ibaia\"         #>  [7] \"Urola Ibaia\"        \"Deba Ibaia\"         \"Rio Nervion\"        #> [10] \"Ibaizabal Ibaia\"    \"Rio Agüera O Mayor\" \"Rio Ason\"           #> [13] \"Rio Miera\"          \"Rio Pas\"            \"Rio Saja\"           #> [16] \"Rio Besaya\"         \"Rio Nansa\"          \"Rio Deva\"           #> [19] \"Rio Cares\"          \"Rio Sella\"          \"Rio Piloña\"         #> [22] \"Rio Nalon\"          \"Rio Narcea\"         \"Rio Pigüeña\"        #> [25] \"Rio Nora\"           \"Rio Trubia\"         \"Rio Esva\"           #> [28] \"Rio Barcena\"        \"Rio Navia\"          \"Rio Navia\"          #> [31] \"Rio Navia\"          \"Rio Navia\"          \"Rio Navia\"          #> [34] \"Rio Agueira\"        \"Rio Eo\"             \"Rio Masma\"          #> [37] \"Rio Landro\"         \"Rio Sor\"            \"Rio Mera\"           #> [40] \"Rio Eume\"           \"Rio Eume\"           \"Rio Eume\"           #> [43] \"Rio Mandeo\"         \"Rio Mero\"           \"Rio Anllons\"        #> [46] \"Rio Xallas\"         \"Rio Xallas\"         \"Rio Xallas\"         #> [49] \"Rio Tambre\"         \"Rio Ulla\"           \"Rio Ulla\"           #> [52] \"Rio Ulla\"           \"Rio Arnego\"         \"Rio Arnego\"         #> [55] \"Rio Umia\"           \"Rio Lerez\"          \"Rio Verdugo\"        #> [58] \"Rio Miño\"           \"Rio Miño\"           \"Rio Miño\"           #> [61] \"Rio Miño\"           \"Rio Miño\"           \"Rio Miño\"           #> [64] \"Rio Miño\"           \"Rio Tea\"            \"Rio Arnoia\"         #> [67] \"Rio Avia\"           \"Rio Avia\"           \"Rio Avia\"           #> [70] \"Rio Sil\"            \"Rio Sil\"            \"Rio Sil\"            #> [73] \"Rio Sil\"            \"Rio Sil\"            \"Rio Cabe\"           #> [76] \"Rio Mao\"            \"Rio Bibei\"          \"Rio Bibei\"          #> [79] \"Rio Bibei\"          \"Rio Xares\"          \"Rio Xares\"          #> [82] \"Rio Xares\"          \"Rio Conso\"          \"Rio Conso\"          #> [85] \"Rio Camba\"          \"Rio Camba\"          \"Rio Camba\"          #> [88] \"Rio Camba\"          \"Rio Selmo\"          \"Rio Burbia\"         #> [91] \"Rio Boeza\"          \"Rio Neira\"          \"Rio Ladra\"          #> [94] \"Rio Parga\"          \"Rio Limia\"          \"Rio Limia\"          #> [97] \"Rio Limia\"          \"Rio Salas\"          #>   ## Example 4: Use table names inside duckdb ddbs_predicate(\"countries\", \"rivers\", predicate = \"within\", conn, \"NAME_ENGL\") #> ✔ Query successful #> $Spain #> integer(0) #>  #> $France #> integer(0) #>  #> $Italy #> integer(0) #>  #> $Portugal #> integer(0) #>"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_read_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Load spatial vector data from DuckDB into R — ddbs_read_vector","title":"Load spatial vector data from DuckDB into R — ddbs_read_vector","text":"Retrieves data DuckDB table, view, Arrow view geometry column, converts R sf object. function works persistent tables created ddbs_write_vector temporary Arrow views created ddbs_register_vector.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_read_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load spatial vector data from DuckDB into R — ddbs_read_vector","text":"","code":"ddbs_read_vector(   conn,   name,   crs = NULL,   crs_column = \"crs_duckspatial\",   clauses = NULL,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_read_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load spatial vector data from DuckDB into R — ddbs_read_vector","text":"conn connection object DuckDB database name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. clauses character, additional SQL code modify query table (e.g. \"...\", \"ORDER ...\") quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_read_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load spatial vector data from DuckDB into R — ddbs_read_vector","text":"sf object","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_read_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load spatial vector data from DuckDB into R — ddbs_read_vector","text":"","code":"if (FALSE) { # interactive() ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## create random points random_points <- data.frame(   id = 1:5,   x = runif(5, min = -180, max = 180),   y = runif(5, min = -90, max = 90) )  ## convert to sf sf_points <- st_as_sf(random_points, coords = c(\"x\", \"y\"), crs = 4326)  ## Example 1: Write and read persistent table ddbs_write_vector(conn, sf_points, \"points\") ddbs_read_vector(conn, \"points\", crs = 4326)  ## Example 2: Register and read Arrow view (faster, temporary) ddbs_register_vector(conn, sf_points, \"points_view\") ddbs_read_vector(conn, \"points_view\", crs = 4326)  ## disconnect from db ddbs_stop_conn(conn) }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_register_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Register an SF Object as an Arrow Table in DuckDB — ddbs_register_vector","title":"Register an SF Object as an Arrow Table in DuckDB — ddbs_register_vector","text":"function registers Simple Features (SF) object temporary Arrow-backed view DuckDB database. zero-copy operation significantly faster ddbs_write_vector workflows require data permanently materialized database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_register_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Register an SF Object as an Arrow Table in DuckDB — ddbs_register_vector","text":"","code":"ddbs_register_vector(conn, data, name, overwrite = FALSE, quiet = FALSE)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_register_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Register an SF Object as an Arrow Table in DuckDB — ddbs_register_vector","text":"conn connection object DuckDB database data sf object write DuckDB database, path local file can read ST_READ name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_register_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Register an SF Object as an Arrow Table in DuckDB — ddbs_register_vector","text":"TRUE (invisibly) successful registration.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_register_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Register an SF Object as an Arrow Table in DuckDB — ddbs_register_vector","text":"","code":"if (FALSE) { # \\dontrun{ library(duckspatial) library(sf)  conn <- ddbs_create_conn(\"memory\")  nc <- st_read(system.file(\"shape/nc.shp\", package=\"sf\"), quiet = TRUE)  ddbs_register_vector(conn, nc, \"nc_arrow_view\")  dbGetQuery(conn, \"SELECT COUNT(*) FROM nc_arrow_view;\")  ddbs_stop_conn(conn, shutdown = TRUE) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate.html","id":null,"dir":"Reference","previous_headings":"","what":"Rotate geometries around centroid — ddbs_rotate","title":"Rotate geometries around centroid — ddbs_rotate","text":"Rotates geometries sf object DuckDB table. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rotate geometries around centroid — ddbs_rotate","text":"","code":"ddbs_rotate(   x,   angle,   units = c(\"degrees\", \"radians\"),   by_feature = FALSE,   center_x = NULL,   center_y = NULL,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rotate geometries around centroid — ddbs_rotate","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. angle numeric value specifying rotation angle units character string specifying angle units: \"degrees\" (default) \"radians\" by_feature Logical. TRUE, geometric operation applied separately geometry. FALSE (default), geometric operation applied data whole. center_x numeric value X coordinate rotation center. NULL, rotates around centroid geometry center_y numeric value Y coordinate rotation center. NULL, rotates around centroid geometry conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rotate geometries around centroid — ddbs_rotate","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rotate geometries around centroid — ddbs_rotate","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_sf <- st_read(system.file(\"spatial/argentina.geojson\", package = \"duckspatial\"))  ## store in duckdb ddbs_write_vector(conn, argentina_sf, \"argentina\")  ## rotate 45 degrees ddbs_rotate(conn = conn, \"argentina\", angle = 45)  ## rotate 90 degrees around a specific point ddbs_rotate(conn = conn, \"argentina\", angle = 90, center_x = -64, center_y = -34)  ## rotate without using a connection ddbs_rotate(argentina_sf, angle = 45) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate_3d.html","id":null,"dir":"Reference","previous_headings":"","what":"Rotate 3D geometries around an axis — ddbs_rotate_3d","title":"Rotate 3D geometries around an axis — ddbs_rotate_3d","text":"Rotates 3D geometries sf object DuckDB table around X, Y, Z axis. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate_3d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rotate 3D geometries around an axis — ddbs_rotate_3d","text":"","code":"ddbs_rotate_3d(   x,   angle,   units = c(\"degrees\", \"radians\"),   axis = \"x\",   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate_3d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rotate 3D geometries around an axis — ddbs_rotate_3d","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. angle numeric value specifying rotation angle units character string specifying angle units: \"degrees\" (default) \"radians\" axis character string specifying rotation axis: \"x\", \"y\", \"z\" (default = \"x\"). geometry rotates around axis conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate_3d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rotate 3D geometries around an axis — ddbs_rotate_3d","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_rotate_3d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rotate 3D geometries around an axis — ddbs_rotate_3d","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read 3D data countries_sf <- read_sf(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\"))  ## store in duckdb ddbs_write_vector(conn, countries_sf, \"countries\")  ## rotate 45 degrees around X axis (pitch) ddbs_rotate_3d(conn = conn, \"countries\", angle = 45, axis = \"x\")  ## rotate 90 degrees around Y axis (yaw) ddbs_rotate_3d(conn = conn, \"countries\", angle = 30, axis = \"y\")  ## rotate 180 degrees around Z axis (roll) ddbs_rotate_3d(conn = conn, \"countries\", angle = 180, axis = \"z\")  ## rotate without using a connection ddbs_rotate_3d(countries_sf, angle = 45, axis = \"z\") } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_scale.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale geometries by X and Y factors — ddbs_scale","title":"Scale geometries by X and Y factors — ddbs_scale","text":"Scales geometries around centroid geometry. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_scale.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scale geometries by X and Y factors — ddbs_scale","text":"","code":"ddbs_scale(   x,   x_scale = 1,   y_scale = 1,   by_feature = FALSE,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_scale.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale geometries by X and Y factors — ddbs_scale","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. x_scale numeric value specifying scaling factor X direction (default = 1) y_scale numeric value specifying scaling factor Y direction (default = 1) by_feature Logical. TRUE, geometric operation applied separately geometry. FALSE (default), geometric operation applied data whole. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_scale.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scale geometries by X and Y factors — ddbs_scale","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_scale.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scale geometries by X and Y factors — ddbs_scale","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data countries_sf <- read_sf(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\"))  ## store in duckdb ddbs_write_vector(conn, countries_sf, \"countries\")  ## scale to 150% in both directions ddbs_scale(conn = conn, \"countries\", x_scale = 1.5, y_scale = 1.5)  ## scale to 200% horizontally, 50% vertically ddbs_scale(conn = conn, \"countries\", x_scale = 2, y_scale = 0.5)  ## scale all features together (default) ddbs_scale(countries_sf, x_scale = 1.5, y_scale = 1.5, by_feature = FALSE)  ## scale each feature independently ddbs_scale(countries_sf, x_scale = 1.5, y_scale = 1.5, by_feature = TRUE)  } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shear.html","id":null,"dir":"Reference","previous_headings":"","what":"Shear geometries — ddbs_shear","title":"Shear geometries — ddbs_shear","text":"Applies shear transformation geometries sf object DuckDB table. Returns result sf object creates new table database. Shearing skews geometry shifting coordinates proportionally.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shear geometries — ddbs_shear","text":"","code":"ddbs_shear(   x,   x_shear = 0,   y_shear = 0,   by_feature = FALSE,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shear geometries — ddbs_shear","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. x_shear numeric value specifying shear factor X direction (default = 0). unit Y, X coordinates shifted amount y_shear numeric value specifying shear factor Y direction (default = 0). unit X, Y coordinates shifted amount by_feature Logical. TRUE, geometric operation applied separately geometry. FALSE (default), geometric operation applied data whole. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shear geometries — ddbs_shear","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Shear geometries — ddbs_shear","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data countries_sf <- read_sf(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\"))  ## store in duckdb ddbs_write_vector(conn, countries_sf, \"countries\")  ## shear in X direction (creates italic-like effect) ddbs_shear(conn = conn, \"countries\", x_shear = 0.3, y_shear = 0)  ## shear in Y direction ddbs_shear(conn = conn, \"countries\", x_shear = 0, y_shear = 0.3)  ## shear in both directions ddbs_shear(conn = conn, \"countries\", x_shear = 0.2, y_shear = 0.2)  ## shear without using a connection ddbs_shear(countries_sf, x_shear = 0.3, y_shear = 0) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shift.html","id":null,"dir":"Reference","previous_headings":"","what":"Shift geometries by X and Y offsets — ddbs_shift","title":"Shift geometries by X and Y offsets — ddbs_shift","text":"Shifts (translates) geometries sf object DuckDB table. Returns result sf object creates new  table database. function equivalent terra::shift().","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shift geometries by X and Y offsets — ddbs_shift","text":"","code":"ddbs_shift(   x,   dx = 0,   dy = 0,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shift geometries by X and Y offsets — ddbs_shift","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. dx numeric value specifying shift X direction (longitude/easting) dy numeric value specifying shift Y direction (latitude/northing) conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shift geometries by X and Y offsets — ddbs_shift","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_shift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Shift geometries by X and Y offsets — ddbs_shift","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data argentina_sf <- st_read(system.file(\"spatial/argentina.geojson\", package = \"duckspatial\"))  ## store in duckdb ddbs_write_vector(conn, argentina_sf, \"argentina\")  ## shift 10 degrees east and 5 degrees north ddbs_shift(conn = conn, \"argentina\", dx = 10, dy = 5)  ## shift without using a connection ddbs_shift(argentina_sf, dx = 10, dy = 5) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_simplify.html","id":null,"dir":"Reference","previous_headings":"","what":"Simplify geometries — ddbs_simplify","title":"Simplify geometries — ddbs_simplify","text":"Simplifies geometries DuckDB table using Douglas-Peucker algorithm via spatial extension. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_simplify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simplify geometries — ddbs_simplify","text":"","code":"ddbs_simplify(   x,   conn = NULL,   name = NULL,   tolerance,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_simplify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simplify geometries — ddbs_simplify","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object tolerance Tolerance distance simplification. Larger values result simplified geometries. crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string length one specifying column storing CRS (created automatically ddbs_write_vector). Set NULL absent. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_simplify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simplify geometries — ddbs_simplify","text":"sf object simplified geometries TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_simplify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simplify geometries — ddbs_simplify","text":"","code":"if (FALSE) { # \\dontrun{ ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## read data countries_sf <- st_read(system.file(\"spatial/countries.geojson\", package = \"duckspatial\"))  ## store in duckdb ddbs_write_vector(conn, countries_sf, \"countries\")  ## simplify with tolerance of 0.01 ddbs_simplify(\"countries\", conn, tolerance = 0.01)  ## simplify without using a connection ddbs_simplify(countries_sf, tolerance = 0.01) } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_stop_conn.html","id":null,"dir":"Reference","previous_headings":"","what":"Close a duckdb connection — ddbs_stop_conn","title":"Close a duckdb connection — ddbs_stop_conn","text":"Close duckdb connection","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_stop_conn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Close a duckdb connection — ddbs_stop_conn","text":"","code":"ddbs_stop_conn(conn)"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_stop_conn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Close a duckdb connection — ddbs_stop_conn","text":"conn connection object DuckDB database","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_stop_conn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Close a duckdb connection — ddbs_stop_conn","text":"TRUE (invisibly) successful disconnection","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_stop_conn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Close a duckdb connection — ddbs_stop_conn","text":"","code":"if (FALSE) { # interactive() ## load packages library(duckspatial)  ## create an in-memory duckdb database conn <- ddbs_create_conn(dbdir = \"memory\")  ## close the connection ddbs_stop_conn(conn) }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_touches.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial touches predicate — ddbs_touches","title":"Spatial touches predicate — ddbs_touches","text":"Tests geometries x touch geometries y. Returns TRUE geometries share boundary interiors intersect.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_touches.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial touches predicate — ddbs_touches","text":"","code":"ddbs_touches(   x,   y,   conn = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_touches.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial touches predicate — ddbs_touches","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. id_x Character; optional name column x whose values used name list elements. NULL, integer row numbers x used. id_y Character; optional name column y whose values replace integer indices returned element list. sparse logical value. TRUE, returns sparse index list. FALSE, returns dense logical matrix. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_touches.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial touches predicate — ddbs_touches","text":"list element contains indices (IDs) geometries y touch corresponding geometry x. See ddbs_predicate() details.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_touches.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial touches predicate — ddbs_touches","text":"convenience wrapper around ddbs_predicate() predicate = \"touches\".","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_touches.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial touches predicate — ddbs_touches","text":"","code":"## load packages library(dplyr) library(duckspatial) library(sf)  ## read countries data, and rivers countries_sf <- read_sf(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) countries_filter_sf <- countries_sf |> filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\"))  # Find neighboring countries ddbs_touches(countries_filter_sf, countries_sf, id_x = \"NAME_ENGL\", id_y = \"NAME_ENGL\") #> ✔ Query successful #> $Spain #> [1] \"Andorra\"   \"Gibraltar\" \"France\"    \"Portugal\"  #>  #> $France #> [1] \"Andorra\"     \"Belgium\"     \"Switzerland\" \"Spain\"       \"Italy\"       #> [6] \"Germany\"     \"Luxembourg\"  \"Monaco\"      #>  #> $Italy #> [1] \"Austria\"      \"Switzerland\"  \"France\"       \"Vatican City\" \"Slovenia\"     #> [6] \"San Marino\"   #>  #> $Portugal #> [1] \"Spain\" #>"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_union.html","id":null,"dir":"Reference","previous_headings":"","what":"Union of geometries — ddbs_union","title":"Union of geometries — ddbs_union","text":"Computes union geometries sf objects DuckDB tables using. equivalent sf::st_union(). function supports three modes: (1) union geometries single object one geometry, (2) union geometries single object grouped one columns, (3) union geometries two different objects. Returns result sf object creates new table database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_union.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Union of geometries — ddbs_union","text":"","code":"ddbs_union(   x,   y = NULL,   by = NULL,   conn = NULL,   name = NULL,   crs = NULL,   crs_column = \"crs_duckspatial\",   overwrite = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_union.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Union of geometries — ddbs_union","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y optional. second table name, sf object, DuckDB connection compute pairwise union geometries x y. Default NULL optional. Character vector specifying one column names group computing unions. Geometries unioned within group. Default NULL conn connection object DuckDB database. NULL, function runs temporary DuckDB database. name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object crs coordinates reference system data. Specify data crs_column, know CRS. crs_column character string specifying name CRS column. Default \"crs_duckspatial\" overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_union.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Union of geometries — ddbs_union","text":"sf object TRUE (invisibly) table creation","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_union.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Union of geometries — ddbs_union","text":"","code":"if (FALSE) { # \\dontrun{ # load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  # read data rivers_sf <- st_read(system.file(\"spatial/rivers.geojson\", package = \"duckspatial\"))  # store in duckdb ddbs_write_vector(conn, rivers_sf, \"rivers\")  # union all geometries into one ddbs_union(conn = conn, \"rivers\")  # union without using a connection ddbs_union(rivers_sf)  # union geometries grouped by a column ddbs_union(conn = conn, \"rivers\", by = \"RIVER_NAME\")  # store result in a new table ddbs_union(conn = conn, \"rivers\", name = \"rivers_union\") } # }"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_within.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial within predicate — ddbs_within","title":"Spatial within predicate — ddbs_within","text":"Tests geometries x within geometries y. Returns TRUE geometry x completely inside geometry y.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_within.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial within predicate — ddbs_within","text":"","code":"ddbs_within(   x,   y,   conn = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_within.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial within predicate — ddbs_within","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. id_x Character; optional name column x whose values used name list elements. NULL, integer row numbers x used. id_y Character; optional name column y whose values replace integer indices returned element list. sparse logical value. TRUE, returns sparse index list. FALSE, returns dense logical matrix. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_within.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial within predicate — ddbs_within","text":"list element contains indices (IDs) geometries y contain corresponding geometry x. See ddbs_predicate() details.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_within.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial within predicate — ddbs_within","text":"convenience wrapper around ddbs_predicate() predicate = \"within\".","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_within.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial within predicate — ddbs_within","text":"","code":"## load packages library(dplyr) library(duckspatial) library(sf)  ## read countries data, and rivers countries_sf <- read_sf(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\")) rivers_sf <- st_read(system.file(\"spatial/rivers.geojson\", package = \"duckspatial\")) |>   st_transform(st_crs(countries_sf)) #> Reading layer `rivers' from data source  #>   `/home/runner/work/_temp/Library/duckspatial/spatial/rivers.geojson'  #>   using driver `GeoJSON' #> Simple feature collection with 100 features and 1 field #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 2766878 ymin: 2222357 xmax: 3578648 ymax: 2459939 #> Projected CRS: ETRS89-extended / LAEA Europe  ddbs_within(rivers_sf, countries_sf, id_x = \"RIVER_NAME\", id_y = \"NAME_ENGL\") #> ✔ Query successful #> $`Rio Garona` #> [1] \"Spain\" \"Italy\" #>  #> $`Bidasoa Ibaia` #> [1] \"Spain\"    \"France\"   \"Portugal\" #>  #> $`Baztan Ibaia` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Urumea` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Oria Ibaia` #> [1] \"Spain\" \"Italy\" #>  #> $`Oria Ibaia` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Urola Ibaia` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Deba Ibaia` #> [1] \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Nervion` #> [1] \"Spain\"    \"France\"   \"Portugal\" #>  #> $`Ibaizabal Ibaia` #> [1] \"Spain\"    \"Italy\"    \"Portugal\" #>  #> $`Rio Agüera O Mayor` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Ason` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Miera` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Pas` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Saja` #> [1] \"Spain\"    \"France\"   \"Portugal\" #>  #> $`Rio Besaya` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Nansa` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Deva` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Cares` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Sella` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Piloña` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Nalon` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Narcea` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Pigüeña` #> [1] \"Spain\"  \"France\" \"Italy\"  #>  #> $`Rio Nora` #> [1] \"Spain\"    \"France\"   \"Italy\"    \"Portugal\" #>  #> $`Rio Trubia` #> integer(0) #>  #> $`Rio Esva` #> integer(0) #>  #> $`Rio Barcena` #> integer(0) #>  #> $`Rio Navia` #> integer(0) #>  #> $`Rio Navia` #> integer(0) #>  #> $`Rio Navia` #> integer(0) #>  #> $`Rio Navia` #> integer(0) #>  #> $`Rio Navia` #> integer(0) #>  #> $`Rio Agueira` #> integer(0) #>  #> $`Rio Eo` #> integer(0) #>  #> $`Rio Masma` #> integer(0) #>  #> $`Rio Landro` #> integer(0) #>  #> $`Rio Sor` #> integer(0) #>  #> $`Rio Mera` #> integer(0) #>  #> $`Rio Eume` #> integer(0) #>  #> $`Rio Eume` #> integer(0) #>  #> $`Rio Eume` #> integer(0) #>  #> $`Rio Mandeo` #> integer(0) #>  #> $`Rio Mero` #> integer(0) #>  #> $`Rio Anllons` #> integer(0) #>  #> $`Rio Xallas` #> integer(0) #>  #> $`Rio Xallas` #> integer(0) #>  #> $`Rio Xallas` #> integer(0) #>  #> $`Rio Tambre` #> integer(0) #>  #> $`Rio Ulla` #> integer(0) #>  #> $`Rio Ulla` #> integer(0) #>  #> $`Rio Ulla` #> integer(0) #>  #> $`Rio Arnego` #> integer(0) #>  #> $`Rio Arnego` #> integer(0) #>  #> $`Rio Umia` #> integer(0) #>  #> $`Rio Lerez` #> integer(0) #>  #> $`Rio Verdugo` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Miño` #> integer(0) #>  #> $`Rio Tea` #> integer(0) #>  #> $`Rio Arnoia` #> integer(0) #>  #> $`Rio Avia` #> integer(0) #>  #> $`Rio Avia` #> integer(0) #>  #> $`Rio Avia` #> integer(0) #>  #> $`Rio Sil` #> integer(0) #>  #> $`Rio Sil` #> integer(0) #>  #> $`Rio Sil` #> integer(0) #>  #> $`Rio Sil` #> integer(0) #>  #> $`Rio Sil` #> integer(0) #>  #> $`Rio Cabe` #> integer(0) #>  #> $`Rio Mao` #> integer(0) #>  #> $`Rio Bibei` #> integer(0) #>  #> $`Rio Bibei` #> integer(0) #>  #> $`Rio Bibei` #> integer(0) #>  #> $`Rio Xares` #> integer(0) #>  #> $`Rio Xares` #> integer(0) #>  #> $`Rio Xares` #> integer(0) #>  #> $`Rio Conso` #> integer(0) #>  #> $`Rio Conso` #> integer(0) #>  #> $`Rio Camba` #> integer(0) #>  #> $`Rio Camba` #> integer(0) #>  #> $`Rio Camba` #> integer(0) #>  #> $`Rio Camba` #> integer(0) #>  #> $`Rio Selmo` #> integer(0) #>  #> $`Rio Burbia` #> integer(0) #>  #> $`Rio Boeza` #> integer(0) #>  #> $`Rio Neira` #> integer(0) #>  #> $`Rio Ladra` #> integer(0) #>  #> $`Rio Parga` #> integer(0) #>  #> $`Rio Limia` #> integer(0) #>  #> $`Rio Limia` #> integer(0) #>  #> $`Rio Limia` #> integer(0) #>  #> $`Rio Limia` #> integer(0) #>  #> $`Rio Salas` #> integer(0) #>"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_within_properly.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial within properly predicate — ddbs_within_properly","title":"Spatial within properly predicate — ddbs_within_properly","text":"Tests geometries x properly within geometries y. Returns TRUE geometry x completely inside geometry y touch boundary.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_within_properly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial within properly predicate — ddbs_within_properly","text":"","code":"ddbs_within_properly(   x,   y,   conn = NULL,   id_x = NULL,   id_y = NULL,   sparse = TRUE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_within_properly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial within properly predicate — ddbs_within_properly","text":"x sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. Data returned object. y sf spatial object. Alternatively, can string name table geometry column within DuckDB database conn. conn connection object DuckDB database. NULL, function runs temporary DuckDB database. id_x Character; optional name column x whose values used name list elements. NULL, integer row numbers x used. id_y Character; optional name column y whose values replace integer indices returned element list. sparse logical value. TRUE, returns sparse index list. FALSE, returns dense logical matrix. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_within_properly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial within properly predicate — ddbs_within_properly","text":"list element contains indices (IDs) geometries y properly contain corresponding geometry x. See ddbs_predicate() details.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_within_properly.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial within properly predicate — ddbs_within_properly","text":"convenience wrapper around ddbs_predicate() predicate = \"within_properly\".","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_within_properly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial within properly predicate — ddbs_within_properly","text":"","code":"## load packages library(dplyr) library(duckspatial) library(sf)  ## read countries data, and rivers countries_sf <- read_sf(system.file(\"spatial/countries.geojson\", package = \"duckspatial\")) |>   filter(CNTR_ID %in% c(\"PT\", \"ES\", \"FR\", \"IT\")) rivers_sf <- st_read(system.file(\"spatial/rivers.geojson\", package = \"duckspatial\")) |>   st_transform(st_crs(countries_sf)) #> Reading layer `rivers' from data source  #>   `/home/runner/work/_temp/Library/duckspatial/spatial/rivers.geojson'  #>   using driver `GeoJSON' #> Simple feature collection with 100 features and 1 field #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 2766878 ymin: 2222357 xmax: 3578648 ymax: 2459939 #> Projected CRS: ETRS89-extended / LAEA Europe  ddbs_within_properly(countries_sf, rivers_sf, id_x = \"NAME_ENGL\", id_y = \"RIVER_NAME\") #> ✔ Query successful #> $Spain #>  [1] \"Rio Garona\"         \"Baztan Ibaia\"       \"Oria Ibaia\"         #>  [4] \"Oria Ibaia\"         \"Deba Ibaia\"         \"Rio Nervion\"        #>  [7] \"Ibaizabal Ibaia\"    \"Rio Agüera O Mayor\" \"Rio Ason\"           #> [10] \"Rio Miera\"          \"Rio Pas\"            \"Rio Saja\"           #> [13] \"Rio Besaya\"         \"Rio Nansa\"          \"Rio Cares\"          #> [16] \"Rio Piloña\"         \"Rio Nalon\"          \"Rio Narcea\"         #> [19] \"Rio Pigüeña\"        \"Rio Nora\"           \"Rio Trubia\"         #> [22] \"Rio Esva\"           \"Rio Barcena\"        \"Rio Navia\"          #> [25] \"Rio Navia\"          \"Rio Navia\"          \"Rio Navia\"          #> [28] \"Rio Agueira\"        \"Rio Masma\"          \"Rio Landro\"         #> [31] \"Rio Mera\"           \"Rio Eume\"           \"Rio Eume\"           #> [34] \"Rio Eume\"           \"Rio Mandeo\"         \"Rio Mero\"           #> [37] \"Rio Anllons\"        \"Rio Xallas\"         \"Rio Xallas\"         #> [40] \"Rio Xallas\"         \"Rio Tambre\"         \"Rio Ulla\"           #> [43] \"Rio Ulla\"           \"Rio Ulla\"           \"Rio Arnego\"         #> [46] \"Rio Arnego\"         \"Rio Umia\"           \"Rio Lerez\"          #> [49] \"Rio Verdugo\"        \"Rio Miño\"           \"Rio Miño\"           #> [52] \"Rio Miño\"           \"Rio Miño\"           \"Rio Miño\"           #> [55] \"Rio Miño\"           \"Rio Miño\"           \"Rio Tea\"            #> [58] \"Rio Arnoia\"         \"Rio Avia\"           \"Rio Avia\"           #> [61] \"Rio Avia\"           \"Rio Sil\"            \"Rio Sil\"            #> [64] \"Rio Sil\"            \"Rio Sil\"            \"Rio Sil\"            #> [67] \"Rio Cabe\"           \"Rio Mao\"            \"Rio Bibei\"          #> [70] \"Rio Bibei\"          \"Rio Bibei\"          \"Rio Xares\"          #> [73] \"Rio Xares\"          \"Rio Xares\"          \"Rio Conso\"          #> [76] \"Rio Conso\"          \"Rio Camba\"          \"Rio Camba\"          #> [79] \"Rio Camba\"          \"Rio Camba\"          \"Rio Selmo\"          #> [82] \"Rio Burbia\"         \"Rio Boeza\"          \"Rio Neira\"          #> [85] \"Rio Ladra\"          \"Rio Parga\"          \"Rio Limia\"          #> [88] \"Rio Limia\"          \"Rio Limia\"          \"Rio Salas\"          #>  #> $France #> integer(0) #>  #> $Italy #> integer(0) #>  #> $Portugal #> integer(0) #>"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_write_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Write an SF Object to a DuckDB Database — ddbs_write_vector","title":"Write an SF Object to a DuckDB Database — ddbs_write_vector","text":"function writes Simple Features (SF) object DuckDB database new table. table created specified schema DuckDB database.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_write_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write an SF Object to a DuckDB Database — ddbs_write_vector","text":"","code":"ddbs_write_vector(   conn,   data,   name,   overwrite = FALSE,   temp_view = FALSE,   quiet = FALSE )"},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_write_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write an SF Object to a DuckDB Database — ddbs_write_vector","text":"conn connection object DuckDB database data sf object write DuckDB database, path local file can read ST_READ name character string length one specifying name table, character string length two specifying schema table names. NULL (default), function returns result sf object overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL. temp_view TRUE, registers sf object temporary Arrow-backed database 'view' using ddbs_register_vector instead creating persistent table. much faster view persist. Defaults FALSE. quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_write_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write an SF Object to a DuckDB Database — ddbs_write_vector","text":"TRUE (invisibly) successful import","code":""},{"path":"https://cidree.github.io/duckspatial/reference/ddbs_write_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write an SF Object to a DuckDB Database — ddbs_write_vector","text":"","code":"if (FALSE) { # interactive() ## load packages library(duckspatial) library(sf)  # create a duckdb database in memory (with spatial extension) conn <- ddbs_create_conn(dbdir = \"memory\")  ## create random points random_points <- data.frame(   id = 1:5,   x = runif(5, min = -180, max = 180),  # Random longitude values   y = runif(5, min = -90, max = 90)     # Random latitude values )  ## convert to sf sf_points <- st_as_sf(random_points, coords = c(\"x\", \"y\"), crs = 4326)  ## insert data into the database ddbs_write_vector(conn, sf_points, \"points\")  ## read data back into R ddbs_read_vector(conn, \"points\", crs = 4326)  ## disconnect from db dbDisconnect(conn) }"},{"path":"https://cidree.github.io/duckspatial/reference/feedback_query.html","id":null,"dir":"Reference","previous_headings":"","what":"Feedback for query success — feedback_query","title":"Feedback for query success — feedback_query","text":"Feedback query success","code":""},{"path":"https://cidree.github.io/duckspatial/reference/feedback_query.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Feedback for query success — feedback_query","text":"","code":"feedback_query(quiet)"},{"path":"https://cidree.github.io/duckspatial/reference/feedback_query.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Feedback for query success — feedback_query","text":"quiet logical value. TRUE, suppresses informational messages. Defaults FALSE.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/feedback_query.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Feedback for query success — feedback_query","text":"cli message","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_geom_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Get column names in a DuckDB database — get_geom_name","title":"Get column names in a DuckDB database — get_geom_name","text":"Get column names DuckDB database","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_geom_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get column names in a DuckDB database — get_geom_name","text":"","code":"get_geom_name(conn, x, rest = FALSE, collapse = FALSE)"},{"path":"https://cidree.github.io/duckspatial/reference/get_geom_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get column names in a DuckDB database — get_geom_name","text":"conn connection object DuckDB database x name table rest whether return geometry column name, rest columns","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_geom_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get column names in a DuckDB database — get_geom_name","text":"name geometry column table","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_query_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Get names for the query — get_query_name","title":"Get names for the query — get_query_name","text":"Get names query","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_query_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get names for the query — get_query_name","text":"","code":"get_query_name(name)"},{"path":"https://cidree.github.io/duckspatial/reference/get_query_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get names for the query — get_query_name","text":"name table name","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_query_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get names for the query — get_query_name","text":"list fixed names","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_st_predicate.html","id":null,"dir":"Reference","previous_headings":"","what":"Gets predicate name — get_st_predicate","title":"Gets predicate name — get_st_predicate","text":"Gets full predicate name shorter version","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_st_predicate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gets predicate name — get_st_predicate","text":"","code":"get_st_predicate(predicate)"},{"path":"https://cidree.github.io/duckspatial/reference/get_st_predicate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gets predicate name — get_st_predicate","text":"predicate geometry predicate function. Defaults intersects, wrapper ST_Intersects. See details options.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/get_st_predicate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gets predicate name — get_st_predicate","text":"character","code":""},{"path":"https://cidree.github.io/duckspatial/reference/overwrite_table.html","id":null,"dir":"Reference","previous_headings":"","what":"Feedback for overwrite argument — overwrite_table","title":"Feedback for overwrite argument — overwrite_table","text":"Feedback overwrite argument","code":""},{"path":"https://cidree.github.io/duckspatial/reference/overwrite_table.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Feedback for overwrite argument — overwrite_table","text":"","code":"overwrite_table(x, conn, quiet, overwrite)"},{"path":"https://cidree.github.io/duckspatial/reference/overwrite_table.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Feedback for overwrite argument — overwrite_table","text":"x table name conn connection object DuckDB database quiet logical value. TRUE, suppresses informational messages. Defaults FALSE. overwrite Boolean. whether overwrite existing table exists. Defaults FALSE. argument ignored name NULL.","code":""},{"path":"https://cidree.github.io/duckspatial/reference/overwrite_table.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Feedback for overwrite argument — overwrite_table","text":"cli message","code":""},{"path":[]},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"major-changes-0-2-0999","dir":"Changelog","previous_headings":"","what":"MAJOR CHANGES","title":"duckspatial 0.2.0999 dev","text":"conn argument defaults now NULL. parameter mandatory anymore spatial operations, handled internally. argument moved x y arguments. ddbs_filter(): uses intersects ST_Intersects instead intersection. Allow use either sf object DuckDB table input/output every operation. Functions use x y arguments, can indistinctively use sf, DuckDB table name, mixed.","code":""},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"new-features-0-2-0999","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"duckspatial 0.2.0999 dev","text":"Affine functions: ddbs_rotate(), ddbs_rotate_3d(), ddbs_shift(), ddbs_flip(), ddbs_scale(), ddbs_shear(). ddbs_boundary(): returns boundary geometries. ddbs_combine(): combines geometries multi-geometry ddbs_concave_hull(): new function create concave hull enclosing geometry. ddbs_convex_hull(): new function create convex hull enclosing geometry. ddbs_create_conn(): new convenient function create DuckDB connection. ddbs_drivers(): get list GDAL drivers file formats supported DuckDB spatial extension. ddbs_join(): new function perform spatial join operations. ddbs_length(): adds new column length geometries ddbs_area(): adds new column area geometries ddbs_is_valid(): adds new logical column asserting simplicity geometries ddbs_is_valid(): adds new logical column asserting validity geometries ddbs_make_valid(): makes geometries valid ddbs_simplify(): makes geometries simple ddbs_bbox(): calculates bounding box ddbs_union(): union geometries Spatial predicates: spatial predicates included function called ddbs_predicate(), user can specify spatial predicate. Another option, ’s use spatial predicate function, ddbs_intersects(), ddbs_crosses(), ddbs_touches(), etc.","code":""},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"minor-changes-0-2-0999","dir":"Changelog","previous_headings":"","what":"MINOR CHANGES","title":"duckspatial 0.2.0999 dev","text":"functions now parameter quiet allows users suppress informational messages. Closed #3","code":""},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"duckspatial-020","dir":"Changelog","previous_headings":"","what":"duckspatial 0.2.0","title":"duckspatial 0.2.0","text":"CRAN release: 2025-04-29","code":""},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"new-features-0-2-0","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"duckspatial 0.2.0","text":"ddbs_read_vector(): gains new argument clauses modify query table (e.g. “…”, “ORDER …”)","code":""},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"new-functions-0-2-0","dir":"Changelog","previous_headings":"","what":"NEW FUNCTIONS","title":"duckspatial 0.2.0","text":"ddbs_list_tables(): lists table schemas tables inside database ddbs_glimpse(): check first rows table ddbs_buffer(): calculates buffer around input geometry ddbs_centroid(): calculates centroid input geometry ddbs_difference(): calculates geometric difference two objects","code":""},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"improvements-0-2-0","dir":"Changelog","previous_headings":"","what":"IMPROVEMENTS","title":"duckspatial 0.2.0","text":"ddbs_intersection(): overwrite argument defaults FALSE instead NULL Better schemas management. Added support functions.","code":""},{"path":"https://cidree.github.io/duckspatial/news/index.html","id":"duckspatial-010","dir":"Changelog","previous_headings":"","what":"duckspatial 0.1.0","title":"duckspatial 0.1.0","text":"CRAN release: 2025-04-19 Initial CRAN submission.","code":""}]
